<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>lua-yottadb (private functions)</h1>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>yottadb.c</strong></li>
</ul>
<h2>Contents</h2>
<ul>
<li><a href=""><b>Summary</b></a></li>
<br/>
<li><a href="#Functions"><b>Functions</b></a></li>
    <li><a href="#get">get (varname[, subs[, ...]])</a></li>
    <li><a href="#delete">delete (varname[, subs][, ...], type)</a></li>
    <li><a href="#set">set (varname[, subs][, ...], value)</a></li>
    <li><a href="#data">data (varname[, subs[, ...[, ...]]])</a></li>
    <li><a href="#lock_incr">lock_incr (varname[, subs[, ...[, timeout]]])</a></li>
    <li><a href="#lock_decr">lock_decr (varname[, subs[, ...]])</a></li>
    <li><a href="#tp">tp ([transid][, varnames], f[, ...])</a></li>
    <li><a href="#subscript_next">subscript_next (varname[, subs[, ...]])</a></li>
    <li><a href="#subscript_previous">subscript_previous (varname[, subs[, ...]])</a></li>
    <li><a href="#node_next">node_next (varname[, subs[, ...]])</a></li>
    <li><a href="#node_previous">node_previous (varname[, subs])</a></li>
    <li><a href="#lock">lock ([node_specifiers[, timeout]])</a></li>
    <li><a href="#delete_excl">delete_excl (varnames)</a></li>
    <li><a href="#incr">incr (varname[, subs[, increment]])</a></li>
    <li><a href="#str2zwr">str2zwr (s)</a></li>
    <li><a href="#zwr2str">zwr2str (s)</a></li>
<br/>
<li><a href="#YDB_Call_in_functions"><b>YDB Call-in functions </b></a></li>
    <li><a href="#init">init ([signal_blocker])</a></li>
    <li><a href="#block_M_signals">block_M_signals (bool)</a></li>
    <li><a href="#cip">cip (ci_handle, routine_name_handle, type_list, n)</a></li>
    <li><a href="#register_routine">register_routine (routine_name, entrypoint)</a></li>
    <li><a href="#ci_tab_open">ci_tab_open (ci_table_filename)</a></li>
<br/>
<li><a href="#Cachearray_functions"><b>Cachearray functions </b></a></li>
    <li><a href="#cachearray_setmetatable">cachearray_setmetatable (cachearray, metatable)</a></li>
    <li><a href="#cachearray_create">cachearray_create (varname[, t1[, ...]])</a></li>
    <li><a href="#cachearray_append">cachearray_append (cachearray[, ...])</a></li>
    <li><a href="#cachearray_tomutable">cachearray_tomutable (cachearray)</a></li>
    <li><a href="#cachearray_flags">cachearray_flags (cachearray)</a></li>
    <li><a href="#cachearray_subs">cachearray_subs (cachearray, string)</a></li>
    <li><a href="#cachearray_tostring">cachearray_tostring (cachearray[, depth])</a></li>
    <li><a href="#cachearray_depth">cachearray_depth (cachearray)</a></li>
    <li><a href="#cachearray_subscript">cachearray_subscript (depth)</a></li>


</ul>



</div>

<div id="content">

<h1>Module <code>yottadb.c</code></h1>
<p>Private yottadb funtions.</p>
<p> These are not part of the public API and may change.
 Copyright 2021-2022, Mitchell; Copyright 2022-2023, Berwyn Hoyt. See LICENSE.</p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#get">get (varname[, subs[, ...]])</a></td>
	<td class="summary">Gets the value of a variable/node or nil if it has no data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delete">delete (varname[, subs][, ...], type)</a></td>
	<td class="summary">Deletes a node or tree of nodes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set">set (varname[, subs][, ...], value)</a></td>
	<td class="summary">Sets the value of a variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#data">data (varname[, subs[, ...[, ...]]])</a></td>
	<td class="summary">Returns information about a variable/node (except intrinsic variables).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock_incr">lock_incr (varname[, subs[, ...[, timeout]]])</a></td>
	<td class="summary">Attempts to acquire or increment a lock on a variable/node, waiting if requested.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock_decr">lock_decr (varname[, subs[, ...]])</a></td>
	<td class="summary">Decrements a lock on a variable/node, releasing it if possible.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#tp">tp ([transid][, varnames], f[, ...])</a></td>
	<td class="summary">Initiates a transaction.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscript_next">subscript_next (varname[, subs[, ...]])</a></td>
	<td class="summary">Returns the next subscript for a variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscript_previous">subscript_previous (varname[, subs[, ...]])</a></td>
	<td class="summary">Returns the previous subscript for a variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node_next">node_next (varname[, subs[, ...]])</a></td>
	<td class="summary">Returns the full subscript table of the next node after a variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node_previous">node_previous (varname[, subs])</a></td>
	<td class="summary">Returns the full subscript table of the node prior to a variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock">lock ([node_specifiers[, timeout]])</a></td>
	<td class="summary">Releases all locks held and attempts to acquire all requested locks, waiting if requested.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delete_excl">delete_excl (varnames)</a></td>
	<td class="summary">Deletes trees of all local variables except the given ones.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#incr">incr (varname[, subs[, increment]])</a></td>
	<td class="summary">Increments the numeric value of a variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#str2zwr">str2zwr (s)</a></td>
	<td class="summary">Returns the zwrite-formatted version of the given string.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#zwr2str">zwr2str (s)</a></td>
	<td class="summary">Returns the string described by the given zwrite-formatted string.</td>
	</tr>
</table>
<h2><a href="#YDB_Call_in_functions">YDB Call-in functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#init">init ([signal_blocker])</a></td>
	<td class="summary">Initialize ydb and set blocking of M signals.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#block_M_signals">block_M_signals (bool)</a></td>
	<td class="summary">Block or unblock YDB signals for while M code is running.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cip">cip (ci_handle, routine_name_handle, type_list, n)</a></td>
	<td class="summary">Call an M routine.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#register_routine">register_routine (routine_name, entrypoint)</a></td>
	<td class="summary">Register a routine name for subsequent passing to <code>cip()</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ci_tab_open">ci_tab_open (ci_table_filename)</a></td>
	<td class="summary">Open a call-in table using ydb<em>ci</em>tab_open()</td>
	</tr>
</table>
<h2><a href="#Cachearray_functions">Cachearray functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#cachearray_setmetatable">cachearray_setmetatable (cachearray, metatable)</a></td>
	<td class="summary">Set metatable for a cachearray since Lua itself can't set userdata metatables.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cachearray_create">cachearray_create (varname[, t1[, ...]])</a></td>
	<td class="summary">Generate and return a C-style array of subscripts as a userdata.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cachearray_append">cachearray_append (cachearray[, ...])</a></td>
	<td class="summary">Append subscripts to an existing cachearray, creating a copy if it is full at this depth.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cachearray_tomutable">cachearray_tomutable (cachearray)</a></td>
	<td class="summary">Make copy of cachearray that is mutable (having changable subscripts) -- intended for iteration.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cachearray_flags">cachearray_flags (cachearray)</a></td>
	<td class="summary">Return cachearray flags field</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cachearray_subs">cachearray_subs (cachearray, string)</a></td>
	<td class="summary">Substitute final subscript of given mutable cachearray with <a href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cachearray_tostring">cachearray_tostring (cachearray[, depth])</a></td>
	<td class="summary">Return string of cachearray subscripts or empty string if no subscripts.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cachearray_depth">cachearray_depth (cachearray)</a></td>
	<td class="summary">Return the depth of the cachearray.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cachearray_subscript">cachearray_subscript (depth)</a></td>
	<td class="summary">Return the cachearray subscript at the specified depth.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "get"></a>
    <strong>get (varname[, subs[, ...]])</strong>
    </dt>
    <dd>
    Gets the value of a variable/node or nil if it has no data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         is a list of subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string or nil if node has no data
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.get(varname[, {subs} | ...]),  <span class="keyword">or</span>:</pre></li>
        <li><pre class="example">_yottadb.get(cachearray)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "delete"></a>
    <strong>delete (varname[, subs][, ...], type)</strong>
    </dt>
    <dd>
    Deletes a node or tree of nodes.
 <code>_yottadb.YDB_DEL_xxxx</code> are boolean constants and must be supplied as actual boolean
 (not merely convertable to boolean), so that delete() can distinguish them from subscripts.
 Note: <code>_yottadb.YDB_DEL_xxxx</code> values differ from the values in <code>libyottadb.h</code>, but they work the same.
 Specifying type=nil or not supplied is the same as <em>yottadb.YDB</em>DEL_NODE


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         list of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">type</span>
         <code>_yottadb.YDB_DEL_NODE</code> or <code>_yottadb.YDB_DEL_TREE</code>
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.delete(varname[, {subs} | ...][, <span class="global">type</span>=_yottadb.YDB_DEL_xxxx])</pre></li>
        <li><pre class="example">_yottadb.delete(cachearray[, <span class="global">type</span>=_yottadb.YDB_DEL_xxxx])</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "set"></a>
    <strong>set (varname[, subs][, ...], value)</strong>
    </dt>
    <dd>
    Sets the value of a variable/node.
 Raises an error of no such intrinsic variable exists.
 if value = nil then perform delete(node) instead


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         is a list of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">value</span>
         string or number convertible to string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        value
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.set(varname[, {subs} | ...], value),  <span class="keyword">or</span>:</pre></li>
        <li><pre class="example">_yottadb.set(cachearray, value)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "data"></a>
    <strong>data (varname[, subs[, ...[, ...]]])</strong>
    </dt>
    <dd>
    Returns information about a variable/node (except intrinsic variables).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         list of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         list of subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

         <code>_yottadb.YDB_DATA_UNDEF</code> (no value or subtree) or
   <code>_yottadb.YDB_DATA_VALUE_NODESC</code> (value, no subtree) or
   <code>_yottadb.YDB_DATA_NOVALUE_DESC</code> (no value, subtree) or
   <code>_yottadb.YDB_DATA_VALUE_DESC</code> (value and subtree)
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.data(varname[, {subs | ...}]),  <span class="keyword">or</span>:</pre></li>
        <li><pre class="example">_yottadb.data(cachearray)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "lock_incr"></a>
    <strong>lock_incr (varname[, subs[, ...[, timeout]]])</strong>
    </dt>
    <dd>
    Attempts to acquire or increment a lock on a variable/node, waiting if requested.
 Raises an error if a lock could not be acquired.
 Caution: timeout is <em>not</em> optional if <code>...</code> list of subscript is provided.
 Otherwise lock_incr cannot tell whether it is a subscript or a timeout.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         list of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         timeout in seconds to wait for lock
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.lock_incr(varname[, {subs}][, timeout=<span class="number">0</span>])</pre></li>
        <li><pre class="example">_yottadb.lock_incr(varname[, ...], timeout)</pre></li>
        <li><pre class="example">_yottadb.lock_incr(cachearray[, timeout=<span class="number">0</span>])</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "lock_decr"></a>
    <strong>lock_decr (varname[, subs[, ...]])</strong>
    </dt>
    <dd>
    Decrements a lock on a variable/node, releasing it if possible.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         list of subscripts
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.lock_decr(varname[, {subs} | ...]),  <span class="keyword">or</span>:</pre></li>
        <li><pre class="example">_yottadb.lock_decr(cachearray)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "tp"></a>
    <strong>tp ([transid][, varnames], f[, ...])</strong>
    </dt>
    <dd>
    Initiates a transaction.
   Note: restarts are subject to $ZMAXTPTIME after which they cause error <code>%YDB-E-TPTIMEOUT</code>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">transid</span>
         string transaction id
         (<em>optional</em>)
        </li>
        <li><span class="parameter">varnames</span>
         table of local M varnames to restore on transaction restart
   (or {'*'} for all locals) -- restoration does apply to rollback
         (<em>optional</em>)
        </li>
        <li><span class="parameter">f</span>

<p> Lua function to call (can have nested <code>_yottadb.tp()</code> calls for nested transactions).</p>

<ul>
    <li>If f returns nothing or <code>_yottadb.YDB_OK</code>, the transaction's affected globals are committed.</li>
    <li>If f returns <code>_yottadb.YDB_TP_RESTART</code> or <code>_yottadb.YDB_TP_ROLLBACK</code>, the transaction is
     restarted (f will be called again) or not committed, respectively.</li>
    <li>If f errors, the transaction is not committed and the error propagated up the stack.</li>
</ul>

        </li>
        <li><span class="parameter">...</span>
         arguments to pass to f
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.tp([transid,] [varnames,] f[, ...])</pre>
    </ul>

</dd>
    <dt>
    <a name = "subscript_next"></a>
    <strong>subscript_next (varname[, subs[, ...]])</strong>
    </dt>
    <dd>
    Returns the next subscript for a variable/node.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         is a list of subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        : string or nil if there are no more subscripts
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.subscript_next(varname[, {subs} | ...]),  <span class="keyword">or</span>:</pre></li>
        <li><pre class="example">_yottadb.subscript_next(cachearray)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "subscript_previous"></a>
    <strong>subscript_previous (varname[, subs[, ...]])</strong>
    </dt>
    <dd>
    Returns the previous subscript for a variable/node.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         is a list of subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string or nil if there are not any previous subscripts
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.subscript_previous(varname[, {subs} | ...]),  <span class="keyword">or</span>:</pre></li>
        <li><pre class="example">_yottadb.subscript_previous(cachearray)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node_next"></a>
    <strong>node_next (varname[, subs[, ...]])</strong>
    </dt>
    <dd>
    Returns the full subscript table of the next node after a variable/node.
 A next node chain started from varname will eventually reach all nodes under that varname in order.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         is a list of subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table of subscripts for the node or nil if there are no next nodes
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.node_next(varname[, {subs} | ...])</pre>
    </ul>

</dd>
    <dt>
    <a name = "node_previous"></a>
    <strong>node_previous (varname[, subs])</strong>
    </dt>
    <dd>
    Returns the full subscript table of the node prior to a variable/node.
 A previous node chain started from varname will eventually reach all nodes under that varname in reverse order.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table of subscripts for the node or nil if there are no previous nodes
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.node_previous(varname[, {subs}])</pre>
    </ul>

</dd>
    <dt>
    <a name = "lock"></a>
    <strong>lock ([node_specifiers[, timeout]])</strong>
    </dt>
    <dd>
    Releases all locks held and attempts to acquire all requested locks, waiting if requested.
 Raises an error if a lock could not be acquired.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">node_specifiers</span>
        } table of cachearrays of variables/nodes to lock
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         timeout in seconds to wait for lock
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.lock([{node_specifiers}[, timeout=<span class="number">0</span>]])</pre>
    </ul>

</dd>
    <dt>
    <a name = "delete_excl"></a>
    <strong>delete_excl (varnames)</strong>
    </dt>
    <dd>
    Deletes trees of all local variables except the given ones.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varnames</span>
         table of variable names to exclude (no subscripts)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.delete_excl(varnames)</pre>
    </ul>

</dd>
    <dt>
    <a name = "incr"></a>
    <strong>incr (varname[, subs[, increment]])</strong>
    </dt>
    <dd>
    Increments the numeric value of a variable/node.
 Raises an error on overflow.
 Caution: increment is <em>not</em> optional if <code>...</code> list of subscript is provided.
 Otherwise incr cannot tell whether last parameter is a subscript or an increment.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string
        </li>
        <li><span class="parameter">subs</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">increment</span>
         amount to increment by = number, or string-of-a-canonical-number, default=1
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.incr(varname[, {subs}][, increment=<span class="number">1</span>])</pre></li>
        <li><pre class="example">_yottadb.incr(varname[, ...], increment=n)</pre></li>
        <li><pre class="example">_yottadb.incr(cachearray[, increment=<span class="number">1</span>])</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "str2zwr"></a>
    <strong>str2zwr (s)</strong>
    </dt>
    <dd>
    Returns the zwrite-formatted version of the given string.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        zwrite-formatted string
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.str2zwr(s)</pre>
    </ul>

</dd>
    <dt>
    <a name = "zwr2str"></a>
    <strong>zwr2str (s)</strong>
    </dt>
    <dd>
    Returns the string described by the given zwrite-formatted string.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         zwrite-formatted string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.zwr2str(s)</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="YDB_Call_in_functions"></a>YDB Call-in functions </h2>

    <dl class="function">
    <dt>
    <a name = "init"></a>
    <strong>init ([signal_blocker])</strong>
    </dt>
    <dd>
    Initialize ydb and set blocking of M signals.
 If <code>signal_blocker</code> is specified, block M signals which could otherwise interrupt slow IO operations like reading from user/pipe.
 Assert any errors.
 Also read the notes on signals in the README.
 Note: any calls to the YDB API also initialize YDB; any subsequent call here will set <code>signal_blocker</code> but not re-init YDB.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">signal_blocker</span>
         specifies a Lua callback CFunction (e.g. <code>yottadb.block_M_signals()</code>) which will be
 called with parameter false on entry to M, and with true on exit from M, so as to unblock YDB signals while M is in use.
 Setting <code>signal_blocker</code> to nil switches off signal blocking.</p>

<p> Note: Changing this to support a generic Lua function as callback would be possible but slow, as it would require
 fetching the function pointer from a C closure, and using <code>lua_call()</code>.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        nothing
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb_c.html#block_M_signals">block_M_signals</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.init(signal_blocker)</pre>
    </ul>

</dd>
    <dt>
    <a name = "block_M_signals"></a>
    <strong>block_M_signals (bool)</strong>
    </dt>
    <dd>
    Block or unblock YDB signals for while M code is running.
 This function is designed to be passed to yottadb.init() as the <code>signal_blocker</code> parameter.
 Most signals (listed in <code>BLOCKED_SIGNALS</code> in callins.c) are blocked using sigprocmask()
 but SIGLARM is not blocked; instead, sigaction() is used to set its <code>SA_RESTART</code> flag while
 in Lua, and cleared while in M. This makes the OS automatically restart IO calls that are
 interrupted by SIGALRM. The benefit of this over blocking is that the YDB SIGALRM
 handler does actually run, allowing YDB to flush the database or IO as necessary without
 your M code having to call the M command <code>VIEW &quot;FLUSH&quot;</code>.
 Note: this function does take time, as OS calls are slow. Using it will increase the M calling
 overhead by about 1.4 microseconds: 2-5x the bare calling overhead (see <code>make benchmarks</code>)
 The call to init() already saves initial values of SIGALRM flags and Sigmask to reduce
 OS calls and make it as fast as possible.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bool</span>
         true to block; false to unblock all YDB signals
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        nothing
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb_c.html#init">init</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">yottadb.block_M_signals(bool)</pre>
    </ul>

</dd>
    <dt>
    <a name = "cip"></a>
    <strong>cip (ci_handle, routine_name_handle, type_list, n)</strong>
    </dt>
    <dd>

<p>Call an M routine.
 Notes:</p>

<ul>
    <li>This function is intended to be called by a wrapper in yottadb.lua rather than by the user,
    so validity of <code>type_list</code> array is not checked.</li>
    <li>If you change the number of parameters before <code>var_args</code> then you MUST also adjust <code>CIP_ARGS</code>.</li>
    <li>You must pass float, double, and int as pointers instead of actuals: see note in cast2ydb().</li>
    <li>This is designed for speed, which means all temporary data is allotted on the stack.
    and it does no mallocs unless it has to return strings (which can be large so need malloc).
    This is because mallocs+free takes 200 CPU instructions (50 cycles, 13ns  on my i7) - tested with perf stat.
    So if you want it to be super fast, don't return strings or make them outputs!</li>
    <li>TODO: could improve speed by having caller metadata remember total string-malloc space required and doing just one malloc for all.
    But first check benchmarks first to see if YDB end is slow enough to make optimization meaningless.</li>
</ul>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ci_handle</span>
         is a call-in table opened by <code>ci_tab_open()</code> that contains <code>routine_name</code>
        </li>
        <li><span class="parameter">routine_name_handle</span>
         is the handle of an M routine registered by <code>_yottadb.register_routine()</code>
        </li>
        <li><span class="parameter">type_list</span>
         is a Lua string containing an array of <code>type_spec[]</code> specifying <code>ret_val</code> and each parameter per the call-in table
 (so the number of <code>type_spec</code> array elements must equal (1+n) where n is the number of parameters in the call-in file)
        </li>
        <li><span class="parameter">n</span>
         must list the parameters specified in the call-in table
 each parameter is converted from its Lua type to the correct C type (e.g. <code>ydb_int_t*</code>) before calling the M routine
 an error results if the number of parameters does not match the number specified in the call-in table
 if too few parameters are supplied, an error results
 if too many parameters are supplied, they are ignored (typical Lua behaviour)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Function's return value (unless <code>ret_type=&apos;void&apos;</code>) followed by any params listed as outputs (O or IO) in the call-in table.
 Returned values are all converted from the call-in table type to Lua types
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cip(ci_handle, routine_name_handle, type_list[, param1][, param2][, ...])</pre>
    </ul>

</dd>
    <dt>
    <a name = "register_routine"></a>
    <strong>register_routine (routine_name, entrypoint)</strong>
    </dt>
    <dd>
    Register a routine name for subsequent passing to <code>cip()</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">routine_name</span>
         is the C name of the M routine (first field in the call-in table)
        </li>
        <li><span class="parameter">entrypoint</span>
         is the M entrypoint specified in the call-in table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the handle (a ydb <code>ci_name_descriptor</code> struct in a new Lua userdata object).
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.register_routine(routine_name, entrypoint)</pre>
    </ul>

</dd>
    <dt>
    <a name = "ci_tab_open"></a>
    <strong>ci_tab_open (ci_table_filename)</strong>
    </dt>
    <dd>
    Open a call-in table using ydb<em>ci</em>tab_open()


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ci_table_filename</span>
         refers to the ydb call-in table file to open
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        integer handle to call-in table
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.ci_tab_open(ci_table_filename)</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Cachearray_functions"></a>Cachearray functions </h2>

    <dl class="function">
    <dt>
    <a name = "cachearray_setmetatable"></a>
    <strong>cachearray_setmetatable (cachearray, metatable)</strong>
    </dt>
    <dd>
    Set metatable for a cachearray since Lua itself can't set userdata metatables.
 This is the same as debug.setmetatable(cachearray, mt) but production apps are not supposed to use the debug library.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cachearray</span>
         to set
        </li>
        <li><span class="parameter">metatable</span>
         to use
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        cachearray
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cachearray_setmetatable(cachearray, metatable)</pre>
    </ul>

</dd>
    <dt>
    <a name = "cachearray_create"></a>
    <strong>cachearray_create (varname[, t1[, ...]])</strong>
    </dt>
    <dd>
    Generate and return a C-style array of subscripts as a userdata.
 The resulting full userdata contains a cached C array of varname and subscripts which may be passed
 to raw <code>_yottadb()</code> functions as a speedy subsarray.
 Returned cachearray is always immutable (copied from a mutable one if necessary)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         string (M glvn) or cachearray
        </li>
        <li><span class="parameter">t1</span>
         Table of subscripts (may only be supplied if varname is a string)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         a list of strings to be appended to the cachearray after t1.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        cachearray
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">_yottadb.cachearray_create(varname[, t1][, ...])</pre></li>
        <li><pre class="example">_yottadb.cachearray_create(cachearray[, ...])</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "cachearray_append"></a>
    <strong>cachearray_append (cachearray[, ...])</strong>
    </dt>
    <dd>
    Append subscripts to an existing cachearray, creating a copy if it is full at this depth.
 Append string list '...' to cachearray. If cachearray is full then copy the cachearray
 with free space for the appendage.
 Note: Function may be called by C as it tidies up its Lua stack itself.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cachearray</span>
         is an existing cachearray created by cachearray_create()
        </li>
        <li><span class="parameter">...</span>
         a list of strings to be appended
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        cachearray (the same or new)
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cachearray_append(cachearray[, ...])</pre>
    </ul>

</dd>
    <dt>
    <a name = "cachearray_tomutable"></a>
    <strong>cachearray_tomutable (cachearray)</strong>
    </dt>
    <dd>
    Make copy of cachearray that is mutable (having changable subscripts) -- intended for iteration.
 Allows <code>cachearray_subst()</code> to be used on the cachearray to efficiently iterate subscripts
 without creating a new cachearray for every single iteration.
 Forces <code>cachearray_append()</code> to create child nodes that are copies rather than re-using this cachearray.
 The user can detect whether a node is mutable (could change) using the node's <code>__mutable()</code> method.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cachearray</span>
         userdata created by `cachearray_create()
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        new cachearray
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cachearray_tomutable(cachearray)</pre>
    </ul>

</dd>
    <dt>
    <a name = "cachearray_flags"></a>
    <strong>cachearray_flags (cachearray)</strong>
    </dt>
    <dd>
    Return cachearray flags field


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cachearray</span>
         userdata
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        bitfield <code>flags</code> (see cachearray.h for bit defines)
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cachearray_flags(cachearray)</pre>
    </ul>

</dd>
    <dt>
    <a name = "cachearray_subs"></a>
    <strong>cachearray_subs (cachearray, string)</strong>
    </dt>
    <dd>
    Substitute final subscript of given mutable cachearray with <a href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a>.
 The supplied cachearray must be the product of <code>cachearray_tomutable()</code>.
 This is used only by node:subscripts() to efficiently iterate subscripts
 without creating a new cachearray for every single iteration.
 The user can detect whether a node is mutable using the node's <code>__mutable()</code> method.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cachearray</span>



        </li>
        <li><span class="parameter">string</span>
         to store in the topmost array index (at depth)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        cachearray (which could be a new mutable one if it could not hold the new subscript size)
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cachearray_subst(cachearray, <span class="global">string</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "cachearray_tostring"></a>
    <strong>cachearray_tostring (cachearray[, depth])</strong>
    </dt>
    <dd>
    Return string of cachearray subscripts or empty string if no subscripts.
 Strings are quoted with %q. Numbers are quoted only if they differ from their string representation.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cachearray</span>
         userdata created by <em>yottadb.cachearray</em>create()
        </li>
        <li><span class="parameter">depth</span>
         of subscripts to show (limits cachearray's inherent length)
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        subscript_list, varname
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cachearray_tostring(cachearray[, depth])</pre>
    </ul>

</dd>
    <dt>
    <a name = "cachearray_depth"></a>
    <strong>cachearray_depth (cachearray)</strong>
    </dt>
    <dd>
    Return the depth of the cachearray.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cachearray</span>
         userdata created by <em>yottadb.cachearray</em>create()
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        depth of cachearray
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cachearray_depth(cachearray)</pre>
    </ul>

</dd>
    <dt>
    <a name = "cachearray_subscript"></a>
    <strong>cachearray_subscript (depth)</strong>
    </dt>
    <dd>
    Return the cachearray subscript at the specified depth.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">depth</span>
         integer of subscript to return (0 returns the varname; -n counts back from the last subscript)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        subscript string
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">_yottadb.cachearray_subscript(cachearray, depth)</pre>
    </ul>

</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-05-27 13:29:16 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
