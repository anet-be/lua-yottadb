<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>lua-yottadb</h1>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>yottadb</strong></li>
</ul>
<h2>Contents</h2>
<ul>
<li><a href=""><b>Summary</b></a></li>
<br/>
<li><a href="#High_level_functions"><b>High level functions </b></a></li>
    <li><a href="#dump">dump (node[, subsarray[, maxlines=30]])</a></li>
    <li><a href="#node:dump">node:dump ([maxlines=30])</a></li>
    <li><a href="#node:gettree">node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</a></li>
    <li><a href="#node:settree">node:settree (tbl[, filter[, _seen]])</a></li>
    <li><a href="#require">require (Mprototypes)</a></li>
<br/>
<li><a href="#Low_level_functions"><b>Low level functions </b></a></li>
    <li><a href="#block_M_signals">block_M_signals (bool)</a></li>
    <li><a href="#data">data (varname[, subsarray[, ...]])</a></li>
    <li><a href="#delete_node">delete_node (varname[, subsarray[, ...]])</a></li>
    <li><a href="#delete_tree">delete_tree (varname[, subsarray[, ...]])</a></li>
    <li><a href="#get">get (varname[, subsarray[, ...]])</a></li>
    <li><a href="#get_error_code">get_error_code (message)</a></li>
    <li><a href="#incr">incr (varname[, subsarray][, ...], increment)</a></li>
    <li><a href="#init">init ([signal_blocker])</a></li>
    <li><a href="#lock">lock ([nodes[, timeout]])</a></li>
    <li><a href="#lock_decr">lock_decr (varname[, subsarray[, ...]])</a></li>
    <li><a href="#lock_incr">lock_incr (varname[, subsarray[, ...[, timeout]]])</a></li>
    <li><a href="#node_next">node_next (varname[, subsarray[, ...]])</a></li>
    <li><a href="#node_previous">node_previous (varname[, subsarray[, ...]])</a></li>
    <li><a href="#set">set (varname[, subsarray][, ...], value)</a></li>
    <li><a href="#str2zwr">str2zwr (s)</a></li>
    <li><a href="#subscript_next">subscript_next (varname[, subsarray[, ...]])</a></li>
    <li><a href="#subscript_previous">subscript_previous (varname[, subsarray[, ...]])</a></li>
    <li><a href="#subscripts">subscripts (varname[, subsarray[, ...[, reverse]]])</a></li>
    <li><a href="#ydb_eintr_handler">ydb_eintr_handler ()</a></li>
    <li><a href="#zwr2str">zwr2str (s)</a></li>
<br/>
<li><a href="#Transactions"><b>Transactions </b></a></li>
    <li><a href="#tp">tp ([id][, varnames], f[, ...])</a></li>
    <li><a href="#transaction">transaction ([id][, varnames], f)</a></li>
    <li><a href="#trestart">trestart ()</a></li>
    <li><a href="#trollback">trollback ()</a></li>
<br/>
<li><a href="#Class_node"><b>Class node </b></a></li>
    <li><a href="#node">node (varname[, subsarray][, ...], node)</a></li>
    <li><a href="#node:__ipairs">node:__ipairs ()</a></li>
    <li><a href="#node:__pairs">node:__pairs ([reverse])</a></li>
    <li><a href="#node:delete_tree">node:delete_tree ()</a></li>
    <li><a href="#node:get">node:get ([default])</a></li>
    <li><a href="#node:incr">node:incr ([increment=1])</a></li>
    <li><a href="#node:lock">node:lock (...)</a></li>
    <li><a href="#node:lock_decr">node:lock_decr ()</a></li>
    <li><a href="#node:lock_incr">node:lock_incr (...)</a></li>
    <li><a href="#node:set">node:set (value)</a></li>
    <li><a href="#node:subscripts">node:subscripts ([reverse])</a></li>
<br/>
<li><a href="#Get_node_properties"><b>Get node properties </b></a></li>
    <li><a href="#node:data">node:data ()</a></li>
    <li><a href="#node:has_tree">node:has_tree ()</a></li>
    <li><a href="#node:has_value">node:has_value ()</a></li>
    <li><a href="#node:name">node:name ()</a></li>
    <li><a href="#node:subsarray">node:subsarray ()</a></li>
    <li><a href="#node:varname">node:varname ()</a></li>
<br/>
<li><a href="#Class_key"><b>Class key </b></a></li>
    <li><a href="#key">key (varname[, subsarray])</a></li>
    <li><a href="#key.property">key.property</a></li>
    <li><a href="#key:delete_node">key:delete_node ()</a></li>
    <li><a href="#key:subscript_next">key:subscript_next ([reset])</a></li>
    <li><a href="#key:subscript_previous">key:subscript_previous ([reset])</a></li>
    <li><a href="#key:subscripts">key:subscripts ([reverse])</a></li>


</ul>



</div>

<div id="content">

<h1>Module <code>yottadb</code></h1>
<p>Lua-bindings for YottaDB, sponsored by the <a href="https://www.uantwerpen.be/en/library/">University of Antwerp Library</a>.</p>
<p> See <a href="https://github.com/anet-be/lua-yottadb/blob/master/README.md">README</a> for a quick introduction with examples. <br>
 Home page: <a href="https://github.com/anet-be/lua-yottadb/">https://github.com/anet-be/lua-yottadb/</a></p>


<h2><a href="#High_level_functions">High level functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#dump">dump (node[, subsarray[, maxlines=30]])</a></td>
	<td class="summary">Dump the specified node and its children</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:dump">node:dump ([maxlines=30])</a></td>
	<td class="summary">Dump the specified node and its children</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:gettree">node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</a></td>
	<td class="summary">Fetch database node and subtree and return a Lua table of it.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:settree">node:settree (tbl[, filter[, _seen]])</a></td>
	<td class="summary">Populate database from a table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#require">require (Mprototypes)</a></td>
	<td class="summary">Import Mumps routines as Lua functions specified in ydb 'call-in' file.</td>
	</tr>
</table>
<h2><a href="#Low_level_functions">Low level functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#block_M_signals">block_M_signals (bool)</a></td>
	<td class="summary">Block or unblock YDB signals for while M code is running.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#data">data (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Return whether a node has a value or subtree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delete_node">delete_node (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Deletes the value of a single database variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delete_tree">delete_tree (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Deletes a database variable/node tree/subtree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get">get (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Gets and returns the value of a database variable/node, or <code>nil</code> if the variable/node does not exist.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_error_code">get_error_code (message)</a></td>
	<td class="summary">Get the YDB error code (if any) contained in the given error message.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#incr">incr (varname[, subsarray][, ...], increment)</a></td>
	<td class="summary">Increments the numeric value of a database variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#init">init ([signal_blocker])</a></td>
	<td class="summary">Initialize ydb and set blocking of M signals.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock">lock ([nodes[, timeout]])</a></td>
	<td class="summary">Releases all locks held and attempts to acquire all requested locks, waiting if requested.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock_decr">lock_decr (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Decrements a lock of the same name as {varname, subsarray}, releasing it if possible.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock_incr">lock_incr (varname[, subsarray[, ...[, timeout]]])</a></td>
	<td class="summary">Attempts to acquire or increment a lock of the same name as {varname, subsarray}, waiting if requested.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node_next">node_next (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the full subscript list (think 'path') of the next node after a database variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node_previous">node_previous (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the full subscript list (think 'path') of the previous node after a database variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set">set (varname[, subsarray][, ...], value)</a></td>
	<td class="summary">Sets the value of a database variable/node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#str2zwr">str2zwr (s)</a></td>
	<td class="summary">Returns the zwrite-formatted version of the given string.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscript_next">subscript_next (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the next subscript for a database variable/node, or <code>nil</code> if there isn't one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscript_previous">subscript_previous (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the previous subscript for a database variable/node, or <code>nil</code> if there isn't one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscripts">subscripts (varname[, subsarray[, ...[, reverse]]])</a></td>
	<td class="summary">Returns an iterator for iterating over database <em>sibling</em> subscripts starting from given varname(subs).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ydb_eintr_handler">ydb_eintr_handler ()</a></td>
	<td class="summary">Lua function to call <code>ydb_eintr_handler()</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#zwr2str">zwr2str (s)</a></td>
	<td class="summary">Returns the string described by the given zwrite-formatted string.</td>
	</tr>
</table>
<h2><a href="#Transactions">Transactions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#tp">tp ([id][, varnames], f[, ...])</a></td>
	<td class="summary">Initiates a transaction (low level function).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#transaction">transaction ([id][, varnames], f)</a></td>
	<td class="summary">Returns a high-level transaction-safed version of the given function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#trestart">trestart ()</a></td>
	<td class="summary">Make the currently running transaction function restart immediately.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#trollback">trollback ()</a></td>
	<td class="summary">Make the currently running transaction function rollback immediately and produce a rollback error.</td>
	</tr>
</table>
<h2><a href="#Class_node">Class node </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#node">node (varname[, subsarray][, ...], node)</a></td>
	<td class="summary">Creates and returns a new YottaDB node object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:__ipairs">node:__ipairs ()</a></td>
	<td class="summary">Not implemented - use <code>pairs(node)</code> or <code>node:__pairs()</code> instead.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:__pairs">node:__pairs ([reverse])</a></td>
	<td class="summary">Makes pairs() work - iterate over the child (subnode, subnode_value, subscript) of given node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:delete_tree">node:delete_tree ()</a></td>
	<td class="summary">Delete database tree pointed to by node object</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:get">node:get ([default])</a></td>
	<td class="summary">Get node's value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:incr">node:incr ([increment=1])</a></td>
	<td class="summary">Increment node's value</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock">node:lock (...)</a></td>
	<td class="summary">Releases all locks held and attempts to acquire a lock matching this node, waiting if requested.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock_decr">node:lock_decr ()</a></td>
	<td class="summary">Decrements a lock matching this node, releasing it if possible.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock_incr">node:lock_incr (...)</a></td>
	<td class="summary">Attempts to acquire or increment a lock matching this node, waiting if requested.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:set">node:set (value)</a></td>
	<td class="summary">Set node's value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:subscripts">node:subscripts ([reverse])</a></td>
	<td class="summary">Return iterator over the <em>child</em> subscript names of a node (in M terms, collate from "" to "").</td>
	</tr>
</table>
<h2><a href="#Get_node_properties">Get node properties </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#node:data">node:data ()</a></td>
	<td class="summary">Fetch the 'data' flags of the node @see data</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:has_tree">node:has_tree ()</a></td>
	<td class="summary">Return true if the node has a tree; otherwise false</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:has_value">node:has_value ()</a></td>
	<td class="summary">Return true if the node has a value; otherwise false</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:name">node:name ()</a></td>
	<td class="summary">Fetch the name of the node, i.e.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:subsarray">node:subsarray ()</a></td>
	<td class="summary">Return node's subsarray of subscript strings as a table</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:varname">node:varname ()</a></td>
	<td class="summary">Fetch the varname of the node, i.e.</td>
	</tr>
</table>
<h2><a href="#Class_key">Class key </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#key">key (varname[, subsarray])</a></td>
	<td class="summary">Deprecated object that represents a YDB node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key.property">key.property</a></td>
	<td class="summary">Properties of key object listed here, accessed with dot, unlike the node object's method of using a colon.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:delete_node">key:delete_node ()</a></td>
	<td class="summary">Deprecated way to delete database node value pointed to by node object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscript_next">key:subscript_next ([reset])</a></td>
	<td class="summary">Deprecated way to get next <em>sibling</em> subscript.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscript_previous">key:subscript_previous ([reset])</a></td>
	<td class="summary">Deprecated way to get previous <em>sibling</em> subscript.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscripts">key:subscripts ([reverse])</a></td>
	<td class="summary">Deprecated way to get same-level subscripts from this node onward.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="High_level_functions"></a>High level functions </h2>

    <dl class="function">
    <dt>
    <a name = "dump"></a>
    <strong>dump (node[, subsarray[, maxlines=30]])</strong>
    </dt>
    <dd>
    Dump the specified node and its children


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">node</span>
         Either a node object with <code>...</code> subscripts or glvn varname with <code>...</code> subsarray
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts to add to node -- valid only if the second parameter is a table
         (<em>optional</em>)
        </li>
        <li><span class="parameter">maxlines</span>
         Maximum number of lines to output before stopping dump
         (<em>default</em> 30)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        dump as a string
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">ydb.dump(node, {subsarray, ...}[, maxlines])  OR  ydb.dump(node, sub1, sub2, ...)</pre>
    </ul>

</dd>
    <dt>
    <a name = "node:dump"></a>
    <strong>node:dump ([maxlines=30])</strong>
    </dt>
    <dd>
    Dump the specified node and its children


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">maxlines</span>
         Maximum number of lines to output before stopping dump
         (<em>default</em> 30)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        dump as a string
    </ol>




</dd>
    <dt>
    <a name = "node:gettree"></a>
    <strong>node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</strong>
    </dt>
    <dd>
    Fetch database node and subtree and return a Lua table of it.
 But be aware that order is not preserved by Lua tables.</p>

<p>  Note: special field name <code>__</code> in the returned table indicates the value of the node itself.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">maxdepth</span>
         subscript depth to fetch (nil=infinite; 1 fetches first layer of subscript's values only)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">filter</span>

<p> optional <code>function(node, node_top_subscript_name, value, recurse, depth)</code> or nil</p>

<ul>
    <li>if filter is nil, all values are fetched unfiltered</li>
    <li>if filter is a function it is invoked on every subscript
    to allow it to cast/alter every value and recurse flag;
    note that at node root (depth=0), subscript passed to filter is the empty string ""</li>
    <li>filter may optionally return two items: <code>value</code>, <code>recurse</code> -- copies of the input parameters, optionally altered:
    <ul>
        <li>if filter returns <code>value</code> then gettree will store it in the table for that database subscript/value; or store nothing if <code>value=nil</code></li>
        <li>if filter returns <code>recurse=false</code>, it will prevent recursion deeper into that particular subscript; if <code>nil</code>, it will use the original value of recurse</li>
    </ul></li>
</ul>

         (<em>optional</em>)
        </li>
        <li><span class="parameter">_value</span>
         is for internal use only (to avoid duplicate value fetches, for speed)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">_depth</span>
         is for internal use only (to record depth of recursion) and must start unspecified (nil)
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Lua table containing data
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:settree">settree</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">t = node:gettree()</pre></li>
        <li><pre class="example">node:gettree(<span class="keyword">nil</span>, <span class="global">print</span>) <span class="keyword">end</span>)
 <span class="comment">-- prints details of every node in the tree</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node:settree"></a>
    <strong>node:settree (tbl[, filter[, _seen]])</strong>
    </dt>
    <dd>

<p>Populate database from a table.  In its simpest form:</p>
<pre><code>node:settree({__='berwyn', weight=78, ['!@#$']='junk', appearance={__='handsome', eyes='blue', hair='blond'}, age=yottadb.DELETE})
</code></pre>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">tbl</span>

<p> is the table to store into the database:</p>

<ul>
    <li>special field name <code>__</code> sets the value of the node itself, as opposed to a subnode</li>
    <li>assign special value <code>yottadb.DELETE</code> to a node to delete the value of the node. You cannot delete the whole subtree</li>
</ul>

        </li>
        <li><span class="parameter">filter</span>

<p> optional function(node, key, value) or nil</p>

<ul>
    <li>if filter is nil, all values are set unfiltered</li>
    <li>if filter is a function(node, key, value) it is invoked on every node
    to allow it to cast/alter every key name and value</li>
    <li>filter must return the same or altered: key, value</li>
    <li>type errors can be handled (or ignored) using this function, too.</li>
    <li>if filter returns yottadb.DELETE as value, the key is deleted</li>
    <li>if filter returns nil as key or value, settree will simply not update the current database value</li>
</ul>

         (<em>optional</em>)
        </li>
        <li><span class="parameter">_seen</span>
         is for internal use only (to prevent accidental duplicate sets: bad because order setting is not guaranteed)
         (<em>optional</em>)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "require"></a>
    <strong>require (Mprototypes)</strong>
    </dt>
    <dd>
    Import Mumps routines as Lua functions specified in ydb 'call-in' file.  <br>
 See example call-in file <a href="https://github.com/anet-be/lua-yottadb/blob/master/examples/arithmetic.ci">arithmetic.ci</a>
 and matching M file <a href="https://github.com/anet-be/lua-yottadb/blob/master/examples/arithmetic.m">arithmetic.m</a>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">Mprototypes</span>
         is a list of lines in the format of ydb 'callin' files per ydb_ci().
 If the string contains <code>:</code> it is considered to be the call-in specification itself;
 otherwise it is treated as the filename of a call-in file to be opened and read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        A table of functions analogous to a Lua module.
 Each function in the table will call an M routine specified in <code>Mprototypes</code>.
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Low_level_functions"></a>Low level functions </h2>

    <dl class="function">
    <dt>
    <a name = "block_M_signals"></a>
    <strong>block_M_signals (bool)</strong>
    </dt>
    <dd>
    Block or unblock YDB signals for while M code is running.
 This function is designed to be passed to yottadb.init() as the <code>signal_blocker</code> parameter.
 Most signals (listed in <code>BLOCKED_SIGNALS</code> in callins.c) are blocked using sigprocmask()
 but SIGLARM is not blocked; instead, sigaction() is used to set its SA_RESTART flag while
 in Lua, and cleared while in M. This makes the OS automatically restart IO calls that are
 interrupted by SIGALRM. The benefit of this over blocking is that the YDB SIGALRM
 handler does actually run, allowing YDB to flush the database or IO as necessary without
 your M code having to call the M command <code>VIEW &quot;FLUSH&quot;</code>.</p>

<p> Note: this function does take time, as OS calls are slow. Using it will increase the M calling
 overhead by about 1.4 microseconds: 2-5x the bare calling overhead (see <code>make benchmarks</code>)
 The call to init() already saves initial values of SIGALRM flags and Sigmask to reduce
 OS calls and make it as fast as possible.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bool</span>
         true to block; false to unblock all YDB signals
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        nothing
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#init">init</a>
    </ul>


</dd>
    <dt>
    <a name = "data"></a>
    <strong>data (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Return whether a node has a value or subtree.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        0: (node has neither value nor subtree)</li>
        <li>
        1: node has value, not subtree</li>
        <li>
        10: node has no value, but does have a subtree</li>
        <li>
        11: node has both value and subtree</li>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.data(<span class="string">'varname'</span>[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.data(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "delete_node"></a>
    <strong>delete_node (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Deletes the value of a single database variable/node.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.delete_node(<span class="string">'varname'</span>[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.delete_node(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "delete_tree"></a>
    <strong>delete_tree (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Deletes a database variable/node tree/subtree.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.delete_tree(<span class="string">'varname'</span>[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.delete_tree(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "get"></a>
    <strong>get (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Gets and returns the value of a database variable/node, or <code>nil</code> if the variable/node does not exist.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table {subscripts}
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string value or <code>nil</code>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.get(<span class="string">'varname'</span>[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.get(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "get_error_code"></a>
    <strong>get_error_code (message)</strong>
    </dt>
    <dd>
    Get the YDB error code (if any) contained in the given error message.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">message</span>
         String error message.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        the YDB error code (if any) for the given error message,</li>
        <li>
        or <code>nil</code> if the message is not a YDB error.</li>
    </ol>




</dd>
    <dt>
    <a name = "incr"></a>
    <strong>incr (varname[, subsarray][, ...], increment)</strong>
    </dt>
    <dd>
    Increments the numeric value of a database variable/node.
 Raises an error on overflow.
 Caution: increment is <em>not</em> optional if <code>...</code> list of subscript is provided.
 Otherwise incr() cannot tell whether last parameter is a subscript or an increment.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">increment</span>
         Number or string amount to increment by (default=1)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the new value
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.incr(varname[, {subs}][, increment=<span class="number">1</span>])</pre></li>
        <li><pre class="example">yottadb.incr(varname[, {subs}], ..., increment=n)</pre></li>
        <li><pre class="example">yottadb.incr(cachearray, depth[, increment=<span class="number">1</span>])</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "init"></a>
    <strong>init ([signal_blocker])</strong>
    </dt>
    <dd>
    Initialize ydb and set blocking of M signals.
 If <code>signal_blocker</code> is specified, block M signals which could otherwise interrupt slow IO operations like reading from user/pipe.
 Also read the notes on signals in the README.
 Note: any calls to the YDB API also initialize YDB; any subsequent call here will set <code>signal_blocker</code> but not re-init YDB.
 Assert any errors.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">signal_blocker</span>
         specifies a Lua callback CFunction (e.g. <code>yottadb.block_M_signals()</code>) which will be
 called with parameter false on entry to M, and with true on exit from M, so as to unblock YDB signals while M is in use.
 Setting <code>signal_blocker</code> to nil switches off signal blocking.
 Note: Changing this to support a generic Lua function as callback would be possible but slow, as it would require
 fetching the function pointer from a C closure, and using <code>lua_call()</code>.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        nothing
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#block_M_signals">block_M_signals</a>
    </ul>


</dd>
    <dt>
    <a name = "lock"></a>
    <strong>lock ([nodes[, timeout]])</strong>
    </dt>
    <dd>
    Releases all locks held and attempts to acquire all requested locks, waiting if requested.
 Raises an error yottadb.YDB<em>LOCK</em>TIMEOUT if a lock could not be acquired.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">nodes</span>
         Table array containing {varname[, subs]} or node objects that specify the lock names to lock.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         Integer timeout in seconds to wait for the lock.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>




</dd>
    <dt>
    <a name = "lock_decr"></a>
    <strong>lock_decr (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Decrements a lock of the same name as {varname, subsarray}, releasing it if possible.
 Releasing a lock cannot create an error unless the varname/subsarray names are invalid.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.lock_decr(<span class="string">'varname'</span>[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.lock_decr(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "lock_incr"></a>
    <strong>lock_incr (varname[, subsarray[, ...[, timeout]]])</strong>
    </dt>
    <dd>
    Attempts to acquire or increment a lock of the same name as {varname, subsarray}, waiting if requested.
 Raises a error yottadb.YDB<em>LOCK</em>TIMEOUT if a lock could not be acquired.
 Caution: timeout is <em>not</em> optional if <code>...</code> list of subscript is provided.
 Otherwise lock_incr cannot tell whether it is a subscript or a timeout.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         Integer timeout in seconds to wait for the lock.
  Optional only if subscripts is a table.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.lock_incr(varname[, {subs}][, ...][, timeout=<span class="number">0</span>])</pre></li>
        <li><pre class="example">yottadb.lock_incr(varname[, {subs}], ..., timeout=<span class="number">0</span>)</pre></li>
        <li><pre class="example">yottadb.lock_incr(cachearray, depth[, timeout=<span class="number">0</span>])</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node_next"></a>
    <strong>node_next (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the full subscript list (think 'path') of the next node after a database variable/node.
 A next node chain started from varname will eventually reach all nodes under that varname in order.</p>

<p> Note: <code>node:gettree()</code> may be a better way to iterate a node tree (see comment on <code>yottadb.nodes()</code>)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        0 (always)</li>
        <li>
        list of subscripts for the node, or nil if there isn't a next node</li>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.node_next(<span class="string">'varname'</span>[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.node_next(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node_previous"></a>
    <strong>node_previous (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the full subscript list (think 'path') of the previous node after a database variable/node.
 A previous node chain started from varname will eventually reach all nodes under that varname in reverse order.</p>

<p> Note: <code>node:gettree()</code> may be a better way to iterate a node tree (see comment on <code>yottadb.nodes()</code>)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        0 (always)</li>
        <li>
        list of subscripts for the node, or nil if there isn't a previous node</li>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.node_previous(<span class="string">'varname'</span>[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.node_previous(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "set"></a>
    <strong>set (varname[, subsarray][, ...], value)</strong>
    </dt>
    <dd>
    Sets the value of a database variable/node.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">value</span>
         String/number/nil value to set node to. If this is a number, it is converted to a string. If it is nil, the value is deleted.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        value
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.set(varname[, {subs}][, ...], value)</pre></li>
        <li><pre class="example">yottadb.set(cachearray, depth, value)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "str2zwr"></a>
    <strong>str2zwr (s)</strong>
    </dt>
    <dd>
    Returns the zwrite-formatted version of the given string.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         String to format.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        formatted string
    </ol>




</dd>
    <dt>
    <a name = "subscript_next"></a>
    <strong>subscript_next (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the next subscript for a database variable/node, or <code>nil</code> if there isn't one.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table {subscripts}
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string subscript name, or nil if there are no more subscripts
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.subscript_next(varname[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.subscript_next(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "subscript_previous"></a>
    <strong>subscript_previous (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the previous subscript for a database variable/node, or <code>nil</code> if there isn't one.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table {subscripts}
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string subscript name, or nil if there are no previous subscripts
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.subscript_previous(varname[, {subsarray}][, ...])</pre></li>
        <li><pre class="example">yottadb.subscript_previous(cachearray, depth)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "subscripts"></a>
    <strong>subscripts (varname[, subsarray[, ...[, reverse]]])</strong>
    </dt>
    <dd>
    Returns an iterator for iterating over database <em>sibling</em> subscripts starting from given varname(subs).
 Note: this starts from the given location and gives the next <em>sibling</em> subscript in the M collation sequence.
 It operates differently than <code>node:subscipts()</code> which yields all subscripts that are <em>children</em> of the given node.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by 2 parameters (cachearray, depth)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">reverse</span>
         Flag that indicates whether to iterate backwards.  Not optional when '...' is provided
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        iterator
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="keyword">for</span> name <span class="keyword">in</span> yottadb.subscripts(varname[, {subsarray}][, ...]) <span class="keyword">do</span> ... <span class="keyword">end</span></pre></li>
        <li><pre class="example"><span class="keyword">for</span> name <span class="keyword">in</span> yottadb.subscripts(cachearray, depth) <span class="keyword">do</span> ... <span class="keyword">end</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "ydb_eintr_handler"></a>
    <strong>ydb_eintr_handler ()</strong>
    </dt>
    <dd>
    Lua function to call <code>ydb_eintr_handler()</code>.
 If users wish to handle EINTR errors themselves, instead of blocking signals, they should call
 <code>ydb_eintr_handler()</code> when they get an EINTR error, before restarting the erroring OS system call.



    <h3>Returns:</h3>
    <ol>

        YDB_OK on success, and >0 on error (with message in ZSTATUS)
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#block_M_signals">block_M_signals</a>
    </ul>


</dd>
    <dt>
    <a name = "zwr2str"></a>
    <strong>zwr2str (s)</strong>
    </dt>
    <dd>
    Returns the string described by the given zwrite-formatted string.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         String in zwrite format.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Transactions"></a>Transactions </h2>

    <dl class="function">
    <dt>
    <a name = "tp"></a>
    <strong>tp ([id][, varnames], f[, ...])</strong>
    </dt>
    <dd>
    Initiates a transaction (low level function).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
         optional string transaction id. For special ids <code>BA</code> or <code>BATCH</code>, see <a href="https://docs.yottadb.com/ProgrammersGuide/langfeat.html#transaction-processing">ydb docs here</a>.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">varnames</span>
         optional table of local M variable names to restore on transaction restart
   (or <code>{&apos;*&apos;}</code> for all locals) -- restoration does apply to rollback
         (<em>optional</em>)
        </li>
        <li><span class="parameter">f</span>

<p> Function to call. The transaction's affected globals are:</p>

<ul>
    <li>committed if the function returns nothing or <code>yottadb.YDB_OK</code></li>
    <li>restarted if the function returns <code>yottadb.YDB_TP_RESTART</code> (<code>f</code> will be called again) <br>
    Note: restarts are subject to <code>$ZMAXTPTIME</code> after which they cause error <code>%YDB-E-TPTIMEOUT</code></li>
    <li>not committed if the function returns <code>yottadb.YDB_TP_ROLLBACK</code> or errors out.</li>
</ul>

        </li>
        <li><span class="parameter">...</span>
         arguments to pass to <code>f</code>
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#transaction">transaction</a>
    </ul>


</dd>
    <dt>
    <a name = "transaction"></a>
    <strong>transaction ([id][, varnames], f)</strong>
    </dt>
    <dd>
    Returns a high-level transaction-safed version of the given function.  It will be called within
   a yottadb transaction and the dbase globals restored on error or trollback()


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
         optional string transaction id. For special ids <code>BA</code> or <code>BATCH</code>, see <a href="https://docs.yottadb.com/ProgrammersGuide/langfeat.html#transaction-processing">ydb docs here</a>.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">varnames</span>
         optional table of local M variable names to restore on transaction trestart()
   (or <code>{&apos;*&apos;}</code> for all locals) -- restoration does apply to rollback
         (<em>optional</em>)
        </li>
        <li><span class="parameter">f</span>

<p> Function to call. The transaction's affected globals are:</p>

<ul>
    <li>committed if the function returns nothing or <code>yottadb.YDB_OK</code></li>
    <li>restarted if the function returns <code>yottadb.YDB_TP_RESTART</code> (<code>f</code> will be called again) <br>
    Note: restarts are subject to <code>$ZMAXTPTIME</code> after which they cause error <code>%YDB-E-TPTIMEOUT</code></li>
    <li>not committed if the function returns <code>yottadb.YDB_TP_ROLLBACK</code> or errors out.</li>
</ul>

        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        transaction-safed function.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#tp">tp</a>
    </ul>


</dd>
    <dt>
    <a name = "trestart"></a>
    <strong>trestart ()</strong>
    </dt>
    <dd>
    Make the currently running transaction function restart immediately.







</dd>
    <dt>
    <a name = "trollback"></a>
    <strong>trollback ()</strong>
    </dt>
    <dd>
    Make the currently running transaction function rollback immediately and produce a rollback error.







</dd>
</dl>
    <h2 class="section-header "><a name="Class_node"></a>Class node </h2>

    <dl class="function">
    <dt>
    <a name = "node"></a>
    <strong>node (varname[, subsarray][, ...], node)</strong>
    </dt>
    <dd>
    Creates and returns a new YottaDB node object.
 This node has all of the class methods defined below.
 Calling the returned node with one or more string parameters returns a new node further subscripted by those strings.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String variable name.
        </li>
        <li><span class="parameter">subsarray</span>
         table of {subscripts}
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         list of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
        <li><span class="parameter">node</span>
        |key is an existing node or key to copy into a new object (you can turn a <a href="yottadb.html#key">key</a> type into a <a href="yottadb.html#node">node</a> type this way)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        node object with metatable yottadb.node
    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">yottadb.node(<span class="string">'varname'</span>[, {subsarray}][, ...]) <span class="keyword">or</span>:</pre></li>
        <li><pre class="example">yottadb.node(node|key, ...)</pre></li>
        <li><pre class="example">yottadb.node(<span class="string">'varname'</span>)(<span class="string">'sub1'</span>, <span class="string">'sub2'</span>)</pre></li>
        <li><pre class="example">yottadb.node(<span class="string">'varname'</span>, <span class="string">'sub1'</span>, <span class="string">'sub2'</span>)</pre></li>
        <li><pre class="example">yottadb.node(<span class="string">'varname'</span>, {<span class="string">'sub1'</span>, <span class="string">'sub2'</span>})</pre></li>
        <li><pre class="example">yottadb.node(<span class="string">'varname'</span>).sub1.sub2</pre></li>
        <li><pre class="example">yottadb.node(<span class="string">'varname'</span>)[<span class="string">'sub1'</span>][<span class="string">'sub2'</span>]</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node:__ipairs"></a>
    <strong>node:__ipairs ()</strong>
    </dt>
    <dd>
    Not implemented - use <code>pairs(node)</code> or <code>node:__pairs()</code> instead.
 See alternative usage below.
 The reason this is not implemented is that since
  Lua >=5.3 implements ipairs via <code>__index()</code>.
  This would mean that <code>__index()</code> would have to treat integer subscript lookup specially, so:</p>

<ul>
    <li>although <code>node[&apos;abc&apos;]</code>  => produces a new node so that <code>node.abc.def.ghi</code> works</li>
    <li><code>node[1]</code>  => would have to produce value <code>node(1).__</code> so ipairs() works <br>
    Since ipairs() will be little used anyway, the consequent inconsistency discourages implementation.</li>
</ul>

<p> Alternatives using pairs() are as follows:






    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(node) <span class="keyword">do</span>   <span class="keyword">if</span> <span class="keyword">not</span> <span class="global">tonumber</span>(k) <span class="keyword">break</span> <span class="keyword">end</span>   &lt;do_your_stuff with k,v&gt;   <span class="keyword">end</span>
 (this works since standard M order is numbers first <span class="comment">-- unless your db specified another collation)</span></pre></li>
        <li><pre class="example"><span class="backtick"><code>for i=1,1/0 do   v=node[i].__  if not v break then   &amp;lt;do_your_stuff with k,v&amp;gt;   end</code></span>
 (alternative that ensures integer keys)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node:__pairs"></a>
    <strong>node:__pairs ([reverse])</strong>
    </dt>
    <dd>

<p>Makes pairs() work - iterate over the child (subnode, subnode_value, subscript) of given node.
 You can use either <code>pairs(node)</code> or <code>node:pairs()</code>.
 If you need to iterate in reverse (or in Lua 5.1), use node:pairs(reverse) instead of pairs(node).</p>

<p> Notes:</p>

<ul>
    <li>pairs() order is guaranteed to equal the M collation sequence order
    (even though pairs() order is not normally guaranteed for Lua tables).
    This means that pairs() is a reasonable substitute for ipairs which is not implemented.</li>
    <li>this is very slightly slower than node:subscripts() which only iterates subscript names without
    creating nodes.</li>
</ul>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         Boolean flag iterates in reverse if true
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        subnode, subnode subnode<em>value</em>or_nil, subscript
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:subscripts">node:subscripts</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">for</span> subscript,subnode <span class="keyword">in</span> <span class="global">pairs</span>(node) <span class="keyword">do</span> ...
     where subnode is a node/key object. If you need its value use node._</pre>
    </ul>

</dd>
    <dt>
    <a name = "node:delete_tree"></a>
    <strong>node:delete_tree ()</strong>
    </dt>
    <dd>
    Delete database tree pointed to by node object





    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#delete_tree">delete_tree</a>
    </ul>


</dd>
    <dt>
    <a name = "node:get"></a>
    <strong>node:get ([default])</strong>
    </dt>
    <dd>
    Get node's value.
 Equivalent to (but 2.5x slower than) <code>node.__</code>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">default</span>
         return value if the node has no data; if not supplied, nil is the default
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        value of the node
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#get">get</a>
    </ul>


</dd>
    <dt>
    <a name = "node:incr"></a>
    <strong>node:incr ([increment=1])</strong>
    </dt>
    <dd>
    Increment node's value


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">increment</span>
         Amount to increment by (negative to decrement)
         (<em>default</em> 1)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the new value
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#incr">incr</a>
    </ul>


</dd>
    <dt>
    <a name = "node:lock"></a>
    <strong>node:lock (...)</strong>
    </dt>
    <dd>
    Releases all locks held and attempts to acquire a lock matching this node, waiting if requested.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>



        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#lock">lock</a>
    </ul>


</dd>
    <dt>
    <a name = "node:lock_decr"></a>
    <strong>node:lock_decr ()</strong>
    </dt>
    <dd>
    Decrements a lock matching this node, releasing it if possible.





    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#lock_decr">lock_decr</a>
    </ul>


</dd>
    <dt>
    <a name = "node:lock_incr"></a>
    <strong>node:lock_incr (...)</strong>
    </dt>
    <dd>
    Attempts to acquire or increment a lock matching this node, waiting if requested.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>



        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#lock_incr">lock_incr</a>
    </ul>


</dd>
    <dt>
    <a name = "node:set"></a>
    <strong>node:set (value)</strong>
    </dt>
    <dd>
    Set node's value.
 Equivalent to (but 4x slower than) <code>node.__ = x</code>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         New value or nil to delete node
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#set">set</a>
    </ul>


</dd>
    <dt>
    <a name = "node:subscripts"></a>
    <strong>node:subscripts ([reverse])</strong>
    </dt>
    <dd>
    Return iterator over the <em>child</em> subscript names of a node (in M terms, collate from "" to "").
 Unlike <code>yottadb.subscripts()</code>, <code>node:subscripts()</code> returns all <em>child</em> subscripts, not subsequent <em>sibling</em> subscripts in the same level.
 Note that subscripts() order is guaranteed to equal the M collation sequence.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         set to true to iterate in reverse order
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        iterator over <em>child</em> subscript names of a node, returning a sequence of subscript name strings
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:__pairs">node:__pairs</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">for</span> subscript <span class="keyword">in</span> node:subscripts() <span class="keyword">do</span> ...</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Get_node_properties"></a>Get node properties </h2>

    <dl class="function">
    <dt>
    <a name = "node:data"></a>
    <strong>node:data ()</strong>
    </dt>
    <dd>
    Fetch the 'data' flags of the node @see data







</dd>
    <dt>
    <a name = "node:has_tree"></a>
    <strong>node:has_tree ()</strong>
    </dt>
    <dd>
    Return true if the node has a tree; otherwise false







</dd>
    <dt>
    <a name = "node:has_value"></a>
    <strong>node:has_value ()</strong>
    </dt>
    <dd>
    Return true if the node has a value; otherwise false







</dd>
    <dt>
    <a name = "node:name"></a>
    <strong>node:name ()</strong>
    </dt>
    <dd>
    Fetch the name of the node, i.e.  the rightmost subscript







</dd>
    <dt>
    <a name = "node:subsarray"></a>
    <strong>node:subsarray ()</strong>
    </dt>
    <dd>
    Return node's subsarray of subscript strings as a table







</dd>
    <dt>
    <a name = "node:varname"></a>
    <strong>node:varname ()</strong>
    </dt>
    <dd>
    Fetch the varname of the node, i.e.  the leftmost subscript







</dd>
</dl>
    <h2 class="section-header "><a name="Class_key"></a>Class key </h2>

    <dl class="function">
    <dt>
    <a name = "key"></a>
    <strong>key (varname[, subsarray])</strong>
    </dt>
    <dd>

<p>Deprecated object that represents a YDB node.
 <code>key()</code> is a subclass of <code>node()</code> designed to implement deprecated
 property names for backward compatibility, as follows:</p>

<ul>
    <li><a href="yottadb.html#node:name">name</a> (this node's subscript or variable name)</li>
    <li><code>value</code> (this node's value in the YottaDB database)</li>
    <li><a href="yottadb.html#data">data</a> (see data())</li>
    <li><a href="yottadb.html#node:has_value">has_value</a> (whether or not this node has a value)</li>
    <li><a href="yottadb.html#node:has_tree">has_tree</a> (whether or not this node has a subtree)</li>
    <li><code>__varname</code> database variable name string -- for compatibility with a previous version</li>
    <li><code>__subsarray</code> table array of database subscript name strings -- for compatibility with a previous version
    and deprecated definitions of <code>key:subscript()</code>, <code>key:subscript_next()</code>, <code>key:subscript_previous()</code>. <br></li>
</ul>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String variable name.
        </li>
        <li><span class="parameter">subsarray</span>
         list of subscripts or table {subscripts}
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        key object of the specified node with metatable yottadb._key
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node">node</a>
    </ul>


</dd>
    <dt>
    <a name = "key.property"></a>
    <strong>key.property</strong>
    </dt>
    <dd>
    Properties of key object listed here, accessed with dot, unlike the node object's method of using a colon.
 This kind of property access is for backward compatibility.</p>

<p> For example, access data property with: <code>key.data</code>


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">name</span>
         equivalent to <code>node:name()</code>
        </li>
        <li><span class="parameter">data</span>
         equivalent to <code>node:data()</code>
        </li>
        <li><span class="parameter">has_value</span>
         equivalent to <code>node:has_value()</code>
        </li>
        <li><span class="parameter">has_tree</span>
         equivalent to <code>node:has_tree()</code>
        </li>
        <li><span class="parameter">value</span>
         equivalent to <code>node.__</code>
        </li>
        <li><span class="parameter">__varname</span>
         database variable name string -- for compatibility with a previous version
        </li>
        <li><span class="parameter">__subsarray</span>
         table array of database subscript name strings -- for compatibility with a previous version
        </li>
    </ul>





</dd>
    <dt>
    <a name = "key:delete_node"></a>
    <strong>key:delete_node ()</strong>
    </dt>
    <dd>
    Deprecated way to delete database node value pointed to by node object.  Prefer node:set(nil)





    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#delete_node">delete_node</a></li>
         <li><a href="yottadb.html#set">set</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscript_next"></a>
    <strong>key:subscript_next ([reset])</strong>
    </dt>
    <dd>

<p>Deprecated way to get next <em>sibling</em> subscript.
 Note: this starts from the given location and gives the next <em>sibling</em> subscript in the M collation sequence.
 It operates differently than <code>node:subscipts()</code> which yields all subscripts that are <em>children</em> of the given node.
 Deprecated because:</p>

<ul>
    <li>it keeps dangerous state in the object: causes bugs where old references to it think it's still original</li>
    <li>it is more Lua-esque to iterate all subscripts in the node (think table) using pairs()</li>
    <li>if sibling access becomes a common use-case, it should be reimplemented as an iterator.</li>
</ul>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reset</span>
         If <code>true</code>, resets to the original subscript before any calls to subscript<em>next()
   or subscript</em>previous()
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#node:__pairs">node:__pairs</a></li>
         <li><a href="yottadb.html#subscript_previous">subscript_previous</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscript_previous"></a>
    <strong>key:subscript_previous ([reset])</strong>
    </dt>
    <dd>
    Deprecated way to get previous <em>sibling</em> subscript.
 See notes for subscript_previous()


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reset</span>
         If <code>true</code>, resets to the original subscript before any calls to subscript<em>next()
   or subscript</em>previous()
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#node:__pairs">node:__pairs</a></li>
         <li><a href="yottadb.html#subscript_next">subscript_next</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscripts"></a>
    <strong>key:subscripts ([reverse])</strong>
    </dt>
    <dd>

<p>Deprecated way to get same-level subscripts from this node onward.
 Deprecated because:</p>

<ul>
    <li>pairs() is more Lua-esque</li>
    <li>it was is non-intuitive that k:subscripts() iterates only subsequent subscripts, not all child subscripts</li>
</ul>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         boolean
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#subscripts">subscripts</a>
    </ul>


</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-05-02 01:35:51 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
