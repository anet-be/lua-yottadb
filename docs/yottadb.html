<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>lua-yottadb</h1>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>yottadb</strong></li>
</ul>
<h2>Contents</h2>
<ul>
<li><a href=""><b>Summary</b></a></li>
<br/>
<li><a href="#Low_level_wrapper_functions"><b>Low level wrapper functions </b></a></li>
    <li><a href="#block_M_signals">block_M_signals (bool)</a></li>
    <li><a href="#data">data (varname[, subsarray[, ...]])</a></li>
    <li><a href="#delete_node">delete_node (varname[, subsarray[, ...]])</a></li>
    <li><a href="#delete_tree">delete_tree (varname[, subsarray[, ...]])</a></li>
    <li><a href="#get">get (varname[, subsarray[, ...]])</a></li>
    <li><a href="#get_error_code">get_error_code (message)</a></li>
    <li><a href="#incr">incr (varname[, subsarray][, ...], increment)</a></li>
    <li><a href="#init">init ([signal_blocker])</a></li>
    <li><a href="#lock">lock ([nodes[, timeout]])</a></li>
    <li><a href="#lock_decr">lock_decr (varname[, subsarray[, ...]])</a></li>
    <li><a href="#lock_incr">lock_incr (varname[, subsarray[, ...[, timeout]]])</a></li>
    <li><a href="#node_next">node_next (varname[, subsarray[, ...]])</a></li>
    <li><a href="#node_previous">node_previous (varname[, subsarray[, ...]])</a></li>
    <li><a href="#set">set (varname[, subsarray][, ...], value)</a></li>
    <li><a href="#str2zwr">str2zwr (s)</a></li>
    <li><a href="#subscript_next">subscript_next (varname[, subsarray[, ...]])</a></li>
    <li><a href="#subscript_previous">subscript_previous (varname[, subsarray[, ...]])</a></li>
    <li><a href="#subscripts">subscripts (varname[, subsarray[, ...[, reverse]]])</a></li>
    <li><a href="#ydb_eintr_handler">ydb_eintr_handler ()</a></li>
    <li><a href="#zwr2str">zwr2str (s)</a></li>
<br/>
<li><a href="#Transactions"><b>Transactions </b></a></li>
    <li><a href="#tp">tp ([id][, varnames], f[, ...])</a></li>
    <li><a href="#transaction">transaction ([id][, varnames], f)</a></li>
    <li><a href="#trestart">trestart ()</a></li>
    <li><a href="#trollback">trollback ()</a></li>
<br/>
<li><a href="#High_level_functions"><b>High level functions </b></a></li>
    <li><a href="#dump">dump (node[, ...[, maxlines=30]])</a></li>
    <li><a href="#require">require (Mprototypes)</a></li>
<br/>
<li><a href="#Class_node"><b>Class node </b></a></li>
    <li><a href="#node">node (varname[, subsarray][, ...], node)</a></li>
    <li><a href="#node:__ipairs">node:__ipairs ()</a></li>
    <li><a href="#node:__pairs">node:__pairs ([reverse])</a></li>
    <li><a href="#node:delete_tree">node:delete_tree ()</a></li>
    <li><a href="#node:dump">node:dump ([maxlines=30])</a></li>
    <li><a href="#node:get">node:get ([default])</a></li>
    <li><a href="#node:gettree">node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</a></li>
    <li><a href="#node:incr">node:incr ([increment=1])</a></li>
    <li><a href="#node:lock">node:lock ([timeout])</a></li>
    <li><a href="#node:lock_decr">node:lock_decr ()</a></li>
    <li><a href="#node:lock_incr">node:lock_incr ([timeout])</a></li>
    <li><a href="#node:set">node:set (value)</a></li>
    <li><a href="#node:settree">node:settree (tbl[, filter[, _seen]])</a></li>
    <li><a href="#node:subscripts">node:subscripts ([reverse])</a></li>
<br/>
<li><a href="#Node_properties"><b>Node properties </b></a></li>
    <li><a href="#node:data">node:data ()</a></li>
    <li><a href="#node:depth">node:depth ()</a></li>
    <li><a href="#node:has_tree">node:has_tree ()</a></li>
    <li><a href="#node:has_value">node:has_value ()</a></li>
    <li><a href="#node:ismutable">node:ismutable ()</a></li>
    <li><a href="#node:name">node:name ()</a></li>
    <li><a href="#node:subsarray">node:subsarray ()</a></li>
    <li><a href="#node:varname">node:varname ()</a></li>
<br/>
<li><a href="#Class_key"><b>Class key </b></a></li>
    <li><a href="#key">key (varname[, subsarray])</a></li>
    <li><a href="#key._property_">key._property_</a></li>
    <li><a href="#key:delete_node">key:delete_node ()</a></li>
    <li><a href="#key:subscript_next">key:subscript_next ([reset[, reverse]])</a></li>
    <li><a href="#key:subscript_previous">key:subscript_previous ([reset])</a></li>
    <li><a href="#key:subscripts">key:subscripts ([reverse])</a></li>


</ul>



</div>

<div id="content">

<h1>Module <code>yottadb</code></h1>
<p>Lua-bindings for YottaDB, sponsored by the <a href="https://www.uantwerpen.be/en/library/">University of Antwerp Library</a>.</p>
<p> See <a href="https://github.com/anet-be/lua-yottadb/blob/master/README.md">README</a> for a quick introduction with examples. <br>
 Home page: <a href="https://github.com/anet-be/lua-yottadb/">https://github.com/anet-be/lua-yottadb/</a></p>


<h2><a href="#Low_level_wrapper_functions">Low level wrapper functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#block_M_signals">block_M_signals (bool)</a></td>
	<td class="summary">Block or unblock YDB signals while M code is running.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#data">data (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Return whether a node has a value or subtree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delete_node">delete_node (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Deletes the value of a single database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delete_tree">delete_tree (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Deletes a database variable tree or node subtree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get">get (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Gets and returns the value of a database variable or node; or <code>nil</code> if the variable or node does not exist.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_error_code">get_error_code (message)</a></td>
	<td class="summary">Get the YDB error code (if any) contained in the given error message.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#incr">incr (varname[, subsarray][, ...], increment)</a></td>
	<td class="summary">Increments the numeric value of a database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#init">init ([signal_blocker])</a></td>
	<td class="summary">Initialize ydb and set blocking of M signals.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock">lock ([nodes[, timeout]])</a></td>
	<td class="summary">Releases all locks held and attempts to acquire all requested locks.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock_decr">lock_decr (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Decrements a lock of the same name as {varname, subsarray}, releasing it if possible.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock_incr">lock_incr (varname[, subsarray[, ...[, timeout]]])</a></td>
	<td class="summary">Attempts to acquire or increment a lock named {varname, subsarray}.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node_next">node_next (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the full subscript list of the next node after a database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node_previous">node_previous (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the full subscript list of the previous node after a database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set">set (varname[, subsarray][, ...], value)</a></td>
	<td class="summary">Sets the value of a database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#str2zwr">str2zwr (s)</a></td>
	<td class="summary">Returns the zwrite-formatted version of the given string.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscript_next">subscript_next (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the next subscript for a database variable or node; or <code>nil</code> if there isn't one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscript_previous">subscript_previous (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the previous subscript for a database variable or node; or <code>nil</code> if there isn't one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscripts">subscripts (varname[, subsarray[, ...[, reverse]]])</a></td>
	<td class="summary">Returns an iterator for iterating over database <em>sibling</em> subscripts starting from the node referenced by <a href="yottadb.html#node:varname">varname</a> and <code>subarray</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ydb_eintr_handler">ydb_eintr_handler ()</a></td>
	<td class="summary">Lua function to call <code>ydb_eintr_handler()</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#zwr2str">zwr2str (s)</a></td>
	<td class="summary">Returns the string described by the given zwrite-formatted string.</td>
	</tr>
</table>
<h2><a href="#Transactions">Transactions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#tp">tp ([id][, varnames], f[, ...])</a></td>
	<td class="summary">Initiates a transaction (low level function).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#transaction">transaction ([id][, varnames], f)</a></td>
	<td class="summary">Returns a high-level transaction-safe version of the given function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#trestart">trestart ()</a></td>
	<td class="summary">Make the currently running transaction function restart immediately.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#trollback">trollback ()</a></td>
	<td class="summary">Make the currently running transaction function rollback immediately and produce rollback error YDB<em>TP</em>ROLLBACK</td>
	</tr>
</table>
<h2><a href="#High_level_functions">High level functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#dump">dump (node[, ...[, maxlines=30]])</a></td>
	<td class="summary">Dump the specified node tree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#require">require (Mprototypes)</a></td>
	<td class="summary">Import Mumps routines as Lua functions specified in ydb 'call-in' file.</td>
	</tr>
</table>
<h2><a href="#Class_node">Class node </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#node">node (varname[, subsarray][, ...], node)</a></td>
	<td class="summary">Creates an object that represents a YottaDB node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:__ipairs">node:__ipairs ()</a></td>
	<td class="summary">Not implemented: use <code>pairs(node)</code> or <code>node:__pairs()</code> instead.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:__pairs">node:__pairs ([reverse])</a></td>
	<td class="summary">Implement <code>pairs()</code> by iterating over the children of a given node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:delete_tree">node:delete_tree ()</a></td>
	<td class="summary">Delete database tree pointed to by node object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:dump">node:dump ([maxlines=30])</a></td>
	<td class="summary">Dump the specified node tree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:get">node:get ([default])</a></td>
	<td class="summary">Get <a href="yottadb.html#node">node</a>'s value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:gettree">node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</a></td>
	<td class="summary">Fetch database node and subtree and return a Lua table of it.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:incr">node:incr ([increment=1])</a></td>
	<td class="summary">Increment <a href="yottadb.html#node">node</a>'s value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock">node:lock ([timeout])</a></td>
	<td class="summary">Releases all locks held and attempts to acquire a lock matching this node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock_decr">node:lock_decr ()</a></td>
	<td class="summary">Decrements a lock matching this node, releasing it if possible.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock_incr">node:lock_incr ([timeout])</a></td>
	<td class="summary">Attempts to acquire or increment a lock matching this node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:set">node:set (value)</a></td>
	<td class="summary">Set <a href="yottadb.html#node">node</a>'s value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:settree">node:settree (tbl[, filter[, _seen]])</a></td>
	<td class="summary">Populate database from a table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:subscripts">node:subscripts ([reverse])</a></td>
	<td class="summary">Return iterator over the <em>child</em> subscript names of a node (in M terms, collate from "" to "").</td>
	</tr>
</table>
<h2><a href="#Node_properties">Node properties </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#node:data">node:data ()</a></td>
	<td class="summary">Fetch the 'data' flags of the node @see data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:depth">node:depth ()</a></td>
	<td class="summary">Fetch the depth of the node, i.e.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:has_tree">node:has_tree ()</a></td>
	<td class="summary">Return true if the node has a tree; otherwise false.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:has_value">node:has_value ()</a></td>
	<td class="summary">Return true if the node has a value; otherwise false.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:ismutable">node:ismutable ()</a></td>
	<td class="summary">Return true if the node is mutable; otherwise false.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:name">node:name ()</a></td>
	<td class="summary">Fetch the name of the node, i.e.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:subsarray">node:subsarray ()</a></td>
	<td class="summary">Return <a href="yottadb.html#node">node</a>'s subsarray of subscript strings as a table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:varname">node:varname ()</a></td>
	<td class="summary">Fetch the varname of the node, i.e.</td>
	</tr>
</table>
<h2><a href="#Class_key">Class key </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#key">key (varname[, subsarray])</a></td>
	<td class="summary">Creates an object that represents a YDB node; deprecated after v0.1.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key._property_">key._property_</a></td>
	<td class="summary">Properties of key object that are accessed with a dot.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:delete_node">key:delete_node ()</a></td>
	<td class="summary">Deprecated way to delete database node value pointed to by node object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscript_next">key:subscript_next ([reset[, reverse]])</a></td>
	<td class="summary">Deprecated way to get next <em>sibling</em> subscript.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscript_previous">key:subscript_previous ([reset])</a></td>
	<td class="summary">Deprecated way to get previous <em>sibling</em> subscript.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscripts">key:subscripts ([reverse])</a></td>
	<td class="summary">Deprecated way to get same-level subscripts from this node onward.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Low_level_wrapper_functions"></a>Low level wrapper functions </h2>

    <dl class="function">
    <dt>
    <a name = "block_M_signals"></a>
    <strong>block_M_signals (bool)</strong>
    </dt>
    <dd>
    Block or unblock YDB signals while M code is running.
 This function is designed to be passed to yottadb.init() as the <code>signal_blocker</code> parameter.
 Most signals (listed in <code>BLOCKED_SIGNALS</code> in callins.c) are blocked using sigprocmask()
 but SIGLARM is not blocked; instead, sigaction() is used to set its SA_RESTART flag while
 in Lua, and cleared while in M. This makes the OS automatically restart IO calls that are
 interrupted by SIGALRM. The benefit of this over blocking is that the YDB SIGALRM
 handler does actually run, allowing YDB to flush the database or IO as necessary without
 your M code needing to call the M command <code>VIEW &quot;FLUSH&quot;</code>.</p>

<p> <em>Note:</em> This function does take time, as OS calls are slow. Using it will increase the M calling
 overhead by about 1.4 microseconds, or 2-5x the bare calling overhead (see <code>make benchmarks</code>)
 The call to init() already saves initial values of SIGALRM flags and Sigmask to reduce
 OS calls and make it as fast as possible.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bool</span>
         true to block; false to unblock all YDB signals
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        nothing
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#init">init</a>
    </ul>


</dd>
    <dt>
    <a name = "data"></a>
    <strong>data (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Return whether a node has a value or subtree.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        0: (node has neither value nor subtree)</li>
        <li>
        1: node has value, not subtree</li>
        <li>
        10: node has no value, but does have a subtree</li>
        <li>
        11: node has both value and subtree</li>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">&lt;include setup from example at ydb.set()&gt;
ydb.data(<span class="string">'^Population'</span>)
<span class="comment">-- 10.0
</span>ydb.data(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
<span class="comment">-- 11.0</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "delete_node"></a>
    <strong>delete_node (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Deletes the value of a single database variable or node.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>}, <span class="number">1367000</span>)
ydb.delete_node(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>})
ydb.get(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>})
<span class="comment">-- nil</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "delete_tree"></a>
    <strong>delete_tree (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Deletes a database variable tree or node subtree.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Example:</h3>
    <ul>
        <pre class="example">&lt;include setup from example at ydb.set()&gt;
ydb.get(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
<span class="comment">-- 325737000
</span>ydb.get(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>})
<span class="comment">-- 3929326
</span>ydb.get(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>})
<span class="comment">-- 5308483
</span>ydb.delete_tree(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
ydb.data(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
<span class="comment">-- 0.0</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "get"></a>
    <strong>get (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Gets and returns the value of a database variable or node; or <code>nil</code> if the variable or node does not exist.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string value or <code>nil</code>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">&lt;include setup from example at ydb.set()&gt;
ydb.get(<span class="string">'^Population'</span>)
<span class="comment">-- nil
</span>ydb.get(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>})
<span class="comment">-- 1367000
</span>ydb.get(<span class="string">'$zgbldir'</span>)
<span class="comment">-- /home/ydbuser/.yottadb/r1.34_x86_64/g/yottadb.gld</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "get_error_code"></a>
    <strong>get_error_code (message)</strong>
    </dt>
    <dd>
    Get the YDB error code (if any) contained in the given error message.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">message</span>
         String error message.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        the YDB error code (if any) for the given error message,</li>
        <li>
        or <code>nil</code> if the message is not a YDB error.</li>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
ydb.get_error_code(<span class="string">'YDB Error: -150374122: %YDB-E-ZGBLDIRACC, Cannot access global directory !AD!AD!AD.'</span>)
<span class="comment">-- -150374122</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "incr"></a>
    <strong>incr (varname[, subsarray][, ...], increment)</strong>
    </dt>
    <dd>
    Increments the numeric value of a database variable or node.
 Raises an error on overflow.</p>

<p> <em>Caution:</em> increment is <em>not</em> optional if <code>...</code> list of subscript is provided.
 Otherwise incr() cannot tell whether last parameter is a subscript or an increment.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">increment</span>
         Number or string amount to increment by (default=1)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the new value
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
ydb.get(<span class="string">'num'</span>)
<span class="comment">-- 4
</span>ydb.incr(<span class="string">'num'</span>, <span class="number">3</span>)
<span class="comment">-- 7
</span>ydb.incr(<span class="string">'num'</span>)
<span class="comment">-- 8</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "init"></a>
    <strong>init ([signal_blocker])</strong>
    </dt>
    <dd>
    Initialize ydb and set blocking of M signals.
 If <code>signal_blocker</code> is specified, block M signals which could otherwise interrupt slow IO operations like reading from stdin or a pipe.
 Assert any errors.
 See also the notes on signals in the <a href="https://github.com/anet-be/lua-yottadb#signals--eintr-errors">README</a>.</p>

<p> <em>Note:</em> any calls to the YDB API also initialize YDB; any subsequent call here will set <code>signal_blocker</code> but not re-init YDB.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">signal_blocker</span>
         Specifies a Lua callback CFunction (e.g. <code>yottadb.block_M_signals()</code>) which will be
 called with its one parameter set to false on entry to M, and with true on exit from M, so as to unblock YDB signals while M is in use.
 Setting <code>signal_blocker</code> to <code>nil</code> switches off signal blocking.</p>

<p> <em>Note:</em> Changing this to support a generic Lua function as callback would be possible but slow, as it would require
 fetching the function pointer from a C closure, and using <code>lua_call()</code>.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        nothing
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#block_M_signals">block_M_signals</a>
    </ul>


</dd>
    <dt>
    <a name = "lock"></a>
    <strong>lock ([nodes[, timeout]])</strong>
    </dt>
    <dd>
    Releases all locks held and attempts to acquire all requested locks.
 Returns after <code>timeout</code>, if specified.
 Raises an error yottadb.YDB<em>LOCK</em>TIMEOUT if a lock could not be acquired.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">nodes</span>
         Table array containing {varname[, subs]} or node objects that specify the lock names to lock.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         Integer timeout in seconds to wait for the lock.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>




</dd>
    <dt>
    <a name = "lock_decr"></a>
    <strong>lock_decr (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Decrements a lock of the same name as {varname, subsarray}, releasing it if possible.
 Releasing a lock cannot create an error unless the varname/subsarray names are invalid.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>




</dd>
    <dt>
    <a name = "lock_incr"></a>
    <strong>lock_incr (varname[, subsarray[, ...[, timeout]]])</strong>
    </dt>
    <dd>
    Attempts to acquire or increment a lock named {varname, subsarray}.
 Returns after <code>timeout</code>, if specified.
 Raises a yottadb.YDB<em>LOCK</em>TIMEOUT error if lock could not be acquired.</p>

<p> <em>Caution:</em> timeout is <em>not</em> optional if <code>...</code> list of subscripts is provided.
 Otherwise lock_incr cannot tell whether it is a subscript or a timeout.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         Integer timeout in seconds to wait for the lock.
  Optional only if subscripts is a table.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>




</dd>
    <dt>
    <a name = "node_next"></a>
    <strong>node_next (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the full subscript list of the next node after a database variable or node.
 A next node chain started from varname will eventually reach all nodes under that varname in order.</p>

<p> <em>Note:</em> <code>node:gettree()</code> or <code>node:subscripts()</code> may be a better way to iterate a node tree

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        0 (always)</li>
        <li>
        list of subscripts for the node, or <code>nil</code> if there isn't a next node</li>
    </ol>



    <h3>Examples:</h3>
    <ul>
        <li><pre class="example">&lt;include setup from example at ydb.set()&gt;
<span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>), <span class="string">', '</span>))
<span class="comment">-- Belgium
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>}), <span class="string">', '</span>))
<span class="comment">-- Thailand
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'Thailand'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA, 17900802
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA, 18000804</span></pre></li>
        <li><pre class="example"><span class="comment">-- Note: The format used above to print the next node will give an error if there is no next node, i.e., the value returned is nil.
</span><span class="comment">-- This case will have to be handled gracefully. The following code snippet is one way to handle nil as the return value:
</span>
<span class="keyword">local</span> ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
<span class="global">next</span> = ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>})
<span class="keyword">if</span> <span class="global">next</span> ~= <span class="keyword">nil</span> <span class="keyword">then</span>
  <span class="global">print</span>(<span class="global">table</span>.concat(<span class="global">next</span>, <span class="string">', '</span>))
<span class="keyword">else</span>
  <span class="global">print</span>(<span class="global">next</span>)
<span class="keyword">end</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node_previous"></a>
    <strong>node_previous (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the full subscript list of the previous node after a database variable or node.
 A previous node chain started from varname will eventually reach all nodes under that varname in reverse order.</p>

<p> <em>Note:</em> <code>node:gettree()</code> or <code>node:subscripts()</code> may be a better way to iterate a node tree

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        0 (always)</li>
        <li>
        list of subscripts for the node, or <code>nil</code> if there isn't a previous node</li>
    </ol>



    <h3>Examples:</h3>
    <ul>
        <li><pre class="example">&lt;include setup from example at ydb.set()&gt;
<span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA, 17900802
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>}), <span class="string">', '</span>))
<span class="comment">-- Thailand
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_previous(<span class="string">'^Population'</span>, {<span class="string">'Thailand'</span>}), <span class="string">', '</span>))
<span class="comment">-- Belgium</span></pre></li>
        <li><pre class="example"><span class="comment">-- Note: See the note on handling nil return values in node_next() which applies to node_previous() as well.</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "set"></a>
    <strong>set (varname[, subsarray][, ...], value)</strong>
    </dt>
    <dd>
    Sets the value of a database variable or node.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">value</span>
         The value to assign to the node. If this is a number, it is converted to a string. If it is <code>nil</code>, the node's value, if any, is deleted.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <code>value</code>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>}, <span class="number">1367000</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'Thailand'</span>}, <span class="number">8414000</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>}, <span class="number">325737000</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>}, <span class="number">3929326</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>}, <span class="number">5308483</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "str2zwr"></a>
    <strong>str2zwr (s)</strong>
    </dt>
    <dd>
    Returns the zwrite-formatted version of the given string.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         String to format.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        formatted string
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb=<span class="global">require</span>(<span class="string">'yottadb'</span>)
str=<span class="string">'The quick brown dog\b\b\bfox jumps over the lazy fox\b\b\bdog.'</span>
<span class="global">print</span>(str)
<span class="comment">-- The quick brown fox jumps over the lazy dog.
</span>ydb.str2zwr(str)
<span class="comment">-- "The quick brown dog"_$C(8,8,8)_"fox jumps over the lazy fox"_$C(8,8,8)_"dog."</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "subscript_next"></a>
    <strong>subscript_next (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the next subscript for a database variable or node; or <code>nil</code> if there isn't one.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string subscript name, or <code>nil</code> if there are no more subscripts
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">&lt;include setup from example at ydb.set()&gt;
ydb.subscript_next(<span class="string">'^Population'</span>, {<span class="string">''</span>})
<span class="comment">-- Belgium
</span>ydb.subscript_next(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>})
<span class="comment">-- Thailand
</span>ydb.subscript_next(<span class="string">'^Population'</span>, {<span class="string">'Thailand'</span>})
<span class="comment">-- USA</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "subscript_previous"></a>
    <strong>subscript_previous (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the previous subscript for a database variable or node; or <code>nil</code> if there isn't one.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string subscript name, or <code>nil</code> if there are no previous subscripts
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">&lt;include setup from example at ydb.set()&gt;
ydb.subscript_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">''</span>})
<span class="comment">-- 18000804
</span>ydb.subscript_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>})
<span class="comment">-- 17900802
</span>ydb.subscript_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>})
<span class="comment">-- nil
</span>ydb.subscript_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
<span class="comment">-- Thailand</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "subscripts"></a>
    <strong>subscripts (varname[, subsarray[, ...[, reverse]]])</strong>
    </dt>
    <dd>
    Returns an iterator for iterating over database <em>sibling</em> subscripts starting from the node referenced by <a href="yottadb.html#node:varname">varname</a> and <code>subarray</code>. </p>

<p> <em>Note:</em> this starts from the given location and gives the next <em>sibling</em> subscript in the M collation sequence.
 It operates differently than <code>node:subscipts()</code> which yields all subscripts that are <em>children</em> of the given node,
 and which you may consider to be preferable.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">reverse</span>
         Flag that indicates whether to iterate backwards.  Not optional when '...' is provided
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        iterator
    </ol>




</dd>
    <dt>
    <a name = "ydb_eintr_handler"></a>
    <strong>ydb_eintr_handler ()</strong>
    </dt>
    <dd>
    Lua function to call <code>ydb_eintr_handler()</code>.
 If users wish to handle EINTR errors themselves, instead of blocking signals, they should call
 <code>ydb_eintr_handler()</code> when they get an EINTR error, before restarting the erroring OS system call.

    </ul>


    <h3>Returns:</h3>
    <ol>

        YDB_OK on success, and greater than zero on error (with message in ZSTATUS)
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#block_M_signals">block_M_signals</a>
    </ul>


</dd>
    <dt>
    <a name = "zwr2str"></a>
    <strong>zwr2str (s)</strong>
    </dt>
    <dd>
    Returns the string described by the given zwrite-formatted string.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         String in zwrite format.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb=<span class="global">require</span>(<span class="string">'yottadb'</span>)
str1=<span class="string">'The quick brown dog\b\b\bfox jumps over the lazy fox\b\b\bdog.'</span>
zwr_str=ydb.str2zwr(str1)
<span class="global">print</span>(zwr_str)
<span class="comment">-- "The quick brown dog"_$C(8,8,8)_"fox jumps over the lazy fox"_$C(8,8,8)_"dog."
</span>str2=ydb.zwr2str(zwr_str)
<span class="global">print</span>(str2)
<span class="comment">-- The quick brown fox jumps over the lazy dog.
</span>str1==str2
<span class="comment">-- true</span></pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Transactions"></a>Transactions </h2>

    <dl class="function">
    <dt>
    <a name = "tp"></a>
    <strong>tp ([id][, varnames], f[, ...])</strong>
    </dt>
    <dd>
    Initiates a transaction (low level function).
 Restarts are subject to <code>$ZMAXTPTIME</code> after which they cause error <code>%YDB-E-TPTIMEOUT</code>

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
         optional string transaction id. For special ids <code>BA</code> or <code>BATCH</code>, see <a href="https://docs.yottadb.com/ProgrammersGuide/langfeat.html#transaction-processing">Transaction Processing</a>.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">varnames</span>
         optional table of local M variable names to restore on transaction restart
 (or <code>{&apos;*&apos;}</code> for all locals)
 Restoration applies to rollback.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">f</span>

<p> Function to call. The transaction's affected globals are:</p>

<ul>
    <li>Committed if the function returns nothing or <code>yottadb.YDB_OK</code>.</li>
    <li>Restarted if the function returns <code>yottadb.YDB_TP_RESTART</code> (<code>f</code> will be called again).</li>
    <li>Not committed if the function returns <code>yottadb.YDB_TP_ROLLBACK</code> or errors out.</li>
</ul>

        </li>
        <li><span class="parameter">...</span>
         arguments to pass to <code>f</code>
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#transaction">transaction</a>
    </ul>

    <h3>Examples:</h3>
    <ul>
        <li><pre class="example"><span class="keyword">local</span> ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)

<span class="keyword">function</span> transfer_to_savings(t)
   <span class="keyword">local</span> ok, e = <span class="global">pcall</span>(ydb.incr, <span class="string">'^checking'</span>, -t)
   <span class="keyword">if</span> (ydb.get_error_code(e) == ydb.YDB_TP_RESTART) <span class="keyword">then</span>
      <span class="keyword">return</span> ydb.YDB_TP_RESTART
   <span class="keyword">end</span>
   <span class="keyword">if</span> (<span class="keyword">not</span> ok <span class="keyword">or</span> <span class="global">tonumber</span>(e)&lt;<span class="number">0</span>) <span class="keyword">then</span>
      <span class="keyword">return</span> ydb.YDB_TP_ROLLBACK
   <span class="keyword">end</span>
   <span class="keyword">local</span> ok, e = <span class="global">pcall</span>(ydb.incr, <span class="string">'^savings'</span>, t)
   <span class="keyword">if</span> (ydb.get_error_code(e) == ydb.YDB_TP_RESTART) <span class="keyword">then</span>
      <span class="keyword">return</span> ydb.YDB_TP_RESTART
   <span class="keyword">end</span>
   <span class="keyword">if</span> (<span class="keyword">not</span> ok) <span class="keyword">then</span>
      <span class="keyword">return</span> ydb.YDB_TP_ROLLBACK
   <span class="keyword">end</span>
   <span class="keyword">return</span> ydb.YDB_OK
<span class="keyword">end</span>

ydb.set(<span class="string">'^checking'</span>, <span class="number">200</span>)
ydb.set(<span class="string">'^savings'</span>, <span class="number">85000</span>)

<span class="global">print</span>(<span class="string">"Amount currently in checking account: $"</span> .. ydb.get(<span class="string">'^checking'</span>))
<span class="global">print</span>(<span class="string">"Amount currently in savings account: $"</span> .. ydb.get(<span class="string">'^savings'</span>))

<span class="global">print</span>(<span class="string">"Transferring $10 from checking to savings"</span>)
<span class="keyword">local</span> ok, e = <span class="global">pcall</span>(ydb.tp, <span class="string">''</span>, {<span class="string">'*'</span>}, transfer_to_savings, <span class="number">10</span>)
<span class="keyword">if</span> (<span class="keyword">not</span> e) <span class="keyword">then</span>
   <span class="global">print</span>(<span class="string">"Transfer successful"</span>)
<span class="keyword">elseif</span> (ydb.get_error_code(e) == ydb.YDB_TP_ROLLBACK) <span class="keyword">then</span>
   <span class="global">print</span>(<span class="string">"Transfer not possible. Insufficient funds"</span>)
<span class="keyword">end</span>

<span class="global">print</span>(<span class="string">"Amount in checking account: $"</span> .. ydb.get(<span class="string">'^checking'</span>))
<span class="global">print</span>(<span class="string">"Amount in savings account: $"</span> .. ydb.get(<span class="string">'^savings'</span>))

<span class="global">print</span>(<span class="string">"Transferring $1000 from checking to savings"</span>)
<span class="keyword">local</span> ok, e = <span class="global">pcall</span>(ydb.tp, <span class="string">''</span>, {<span class="string">'*'</span>}, transfer_to_savings, <span class="number">1000</span>)
<span class="keyword">if</span> (<span class="keyword">not</span> e) <span class="keyword">then</span>
   <span class="global">print</span>(<span class="string">"Transfer successful"</span>)
<span class="keyword">elseif</span> (ydb.get_error_code(e) == ydb.YDB_TP_ROLLBACK) <span class="keyword">then</span>
   <span class="global">print</span>(<span class="string">"Transfer not possible. Insufficient funds"</span>)
<span class="keyword">end</span>

<span class="global">print</span>(<span class="string">"Amount in checking account: $"</span> .. ydb.get(<span class="string">'^checking'</span>))
<span class="global">print</span>(<span class="string">"Amount in savings account: $"</span> .. ydb.get(<span class="string">'^savings'</span>))</pre></li>
        <li><pre class="example">Output:
  Amount currently <span class="keyword">in</span> checking account: $<span class="number">200</span>
  Amount currently <span class="keyword">in</span> savings account: $<span class="number">85000</span>
  Transferring $<span class="number">10</span> from checking to savings
  Transfer successful
  Amount <span class="keyword">in</span> checking account: $<span class="number">190</span>
  Amount <span class="keyword">in</span> savings account: $<span class="number">85010</span>
  Transferring $<span class="number">1000</span> from checking to savings
  Transfer <span class="keyword">not</span> possible. Insufficient funds
  Amount <span class="keyword">in</span> checking account: $<span class="number">190</span>
  Amount <span class="keyword">in</span> savings account: $<span class="number">85010</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "transaction"></a>
    <strong>transaction ([id][, varnames], f)</strong>
    </dt>
    <dd>
    Returns a high-level transaction-safe version of the given function.
 It will be called within a yottadb transaction and the dbase globals restored on error or <code>yottadb.trollback()</code>

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
         optional string transaction id. For special ids <code>BA</code> or <code>BATCH</code>, see <a href="https://docs.yottadb.com/ProgrammersGuide/langfeat.html#transaction-processing">Transaction Processing</a>.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">varnames</span>
         optional table of local M variable names to restore on transaction <code>trestart()</code>
 (or <code>{&apos;*&apos;}</code> for all locals). Restoration applies to rollback.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">f</span>

<p> Function to call. The transaction's affected globals are:</p>

<ul>
    <li>Committed if the function returns nothing or <code>yottadb.YDB_OK</code>.</li>
    <li>Restarted if the function returns <code>yottadb.YDB_TP_RESTART</code> (<code>f</code> will be called again).
    Restarts are subject to <code>$ZMAXTPTIME</code> after which they cause error <code>%YDB-E-TPTIMEOUT</code></li>
    <li>Not committed if the function returns <code>yottadb.YDB_TP_ROLLBACK</code> or errors out.</li>
</ul>

        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        transaction-safe function.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#tp">tp</a>
    </ul>

    <h3>Example:</h3>
    <ul>
        <pre class="example">Znode = ydb.node(<span class="string">'^Ztest'</span>)
transact = ydb.transaction(<span class="keyword">function</span>(end_func)
  <span class="global">print</span>(<span class="string">"^Ztest starts as"</span>, Znode:get())
  Znode:set(<span class="string">'value'</span>)
  end_func()
  <span class="keyword">end</span>)

transact(ydb.trollback)  <span class="comment">-- perform a rollback after setting Znode
</span><span class="comment">-- ^Ztest starts as	nil
</span><span class="comment">-- YDB Error: 2147483645: YDB_TP_ROLLBACK
</span><span class="comment">-- stack traceback:
</span><span class="comment">--   [C]: in function '_yottadb.tp' ...
</span>Znode:get()  <span class="comment">-- see that the data didn't get set
</span><span class="comment">-- nil
</span>
tries = <span class="number">2</span>
<span class="keyword">function</span> trier()  tries=tries-<span class="number">1</span>  <span class="keyword">if</span> tries&gt;<span class="number">0</span> <span class="keyword">then</span> ydb.trestart() <span class="keyword">end</span>  <span class="keyword">end</span>
transact(trier)  <span class="comment">-- restart with initial dbase state and try again
</span><span class="comment">-- ^Ztest starts as	nil
</span><span class="comment">-- ^Ztest starts as	nil
</span>Znode:get()  <span class="comment">-- check that the data got set after restart
</span><span class="comment">-- value
</span>
Znode:set(<span class="keyword">nil</span>)
transact(<span class="keyword">function</span>() <span class="keyword">end</span>)  <span class="comment">-- end the transaction normally without restart
</span><span class="comment">-- ^Ztest starts as	nil
</span>Znode:get()  <span class="comment">-- check that the data got set
</span><span class="comment">-- value</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "trestart"></a>
    <strong>trestart ()</strong>
    </dt>
    <dd>
    Make the currently running transaction function restart immediately.

    </ul>






</dd>
    <dt>
    <a name = "trollback"></a>
    <strong>trollback ()</strong>
    </dt>
    <dd>
    Make the currently running transaction function rollback immediately and produce rollback error YDB<em>TP</em>ROLLBACK

    </ul>






</dd>
</dl>
    <h2 class="section-header "><a name="High_level_functions"></a>High level functions </h2>

    <dl class="function">
    <dt>
    <a name = "dump"></a>
    <strong>dump (node[, ...[, maxlines=30]])</strong>
    </dt>
    <dd>
    Dump the specified node tree.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">node</span>
         Either a node object with <code>...</code> subscripts or glvn varname with <code>...</code> subsarray
        </li>
        <li><span class="parameter">...</span>
         Either a table or a list of subscripts to add to node
         (<em>optional</em>)
        </li>
        <li><span class="parameter">maxlines</span>
         Maximum number of lines to output before stopping dump
         (<em>default</em> 30)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        dump as a string
    </ol>



    <h3>Examples:</h3>
    <ul>
        <li><pre class="example">ydb.dump(node, [...[, maxlines]])</pre></li>
        <li><pre class="example">ydb.dump(<span class="string">'^MYVAR'</span>, <span class="string">'people'</span>)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "require"></a>
    <strong>require (Mprototypes)</strong>
    </dt>
    <dd>
    Import Mumps routines as Lua functions specified in ydb 'call-in' file.  <br>
 See example call-in file <a href="https://github.com/anet-be/lua-yottadb/blob/master/examples/arithmetic.ci">arithmetic.ci</a>
 and matching M file <a href="https://github.com/anet-be/lua-yottadb/blob/master/examples/arithmetic.m">arithmetic.m</a>.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">Mprototypes</span>
         A list of lines in the format of ydb 'call-in' files required by <code>ydb_ci()</code>.
 If the string contains <code>:</code> it is considered to be the call-in specification itself;
 otherwise it is treated as the filename of a call-in file to be opened and read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        A table of functions analogous to a Lua module.
 Each function in the table will call an M routine specified in <code>Mprototypes</code>.
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">$ export ydb_routines=examples   # put arithmetic.m (below) into ydb path
$ lua -lyottadb
arithmetic = yottadb.<span class="global">require</span>(<span class="string">'examples/arithmetic.ci'</span>)
arithmetic.add_verbose(<span class="string">"Sum is:"</span>, <span class="number">2</span>, <span class="number">3</span>)
<span class="comment">-- Sum is: 5
</span><span class="comment">-- Sum is: 5
</span>arithmetic.sub(<span class="number">5</span>,<span class="number">7</span>)
<span class="comment">-- -2</span></pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Class_node"></a>Class node </h2>

    <dl class="function">
    <dt>
    <a name = "node"></a>
    <strong>node (varname[, subsarray][, ...], node)</strong>
    </dt>
    <dd>

<p>Creates an object that represents a YottaDB node.
 This node has all of the class methods defined below.
 Calling the returned node with one or more string parameters returns a new node further subscripted by those strings.
 Calling this on an existing node <code>yottadb.node(node)</code> creates an (immutable) copy of node.</p>

<p> <em>Notes:</em></p>

<ul>
    <li>Although the syntax <code>node:method()</code> is pretty, be aware that it is slow. If you are concerned
    about speed, use <code>node:__method()</code> instead, which is equivalent but 15x faster.
    This is because Lua expands <code>node:method()</code> to <code>node.method(node)</code>, so lua-yottadb creates
    an intermediate object of database subnode <code>node.method</code>, assuming it is a database subnode access.
    Then, when this object gets called with <code>()</code>, lua-yottadb discovers that its first parameter is of type <a href="yottadb.html#node">node</a>,
    at which point it finally knows to invoke <code>node.__method()</code> instead of treating it as a database subnode access.</li>
    <li>Because lua-yottadb's underlying method access is with the <code>__</code> prefix, database node names
    starting with two underscores are not accessable using dot notation: instead use mynode('__nodename') to
    access a database node named <code>__nodename</code>. In addition, Lua object methods starting with two underscores,
    like <code>__tostring</code>, are only accessible with an <em>additional</em> <code>__</code> prefix; for example, <code>node:____tostring()</code>.</li>
    <li>Several standard Lua operators work on nodes. These are: <code>+ - = pairs() tostring()</code></li>
</ul>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String variable name.
        </li>
        <li><span class="parameter">subsarray</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         list of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
        <li><span class="parameter">node</span>
         <code>|key:</code> is an existing node or key to copy into a new object (you can turn a <a href="yottadb.html#key">key</a> type into a <a href="yottadb.html#node">node</a> type this way)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        node object with metatable <a href="yottadb.html#node">yottadb.node</a>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">yottadb.node(<span class="string">'varname'</span>[, {subsarray}][, ...])
yottadb.node(node|key[, {}][, ...])
yottadb.node(<span class="string">'varname'</span>)(<span class="string">'sub1'</span>, <span class="string">'sub2'</span>)
yottadb.node(<span class="string">'varname'</span>, <span class="string">'sub1'</span>, <span class="string">'sub2'</span>)
yottadb.node(<span class="string">'varname'</span>, {<span class="string">'sub1'</span>, <span class="string">'sub2'</span>})
yottadb.node(<span class="string">'varname'</span>).sub1.sub2
yottadb.node(<span class="string">'varname'</span>)[<span class="string">'sub1'</span>][<span class="string">'sub2'</span>]</pre>
    </ul>

</dd>
    <dt>
    <a name = "node:__ipairs"></a>
    <strong>node:__ipairs ()</strong>
    </dt>
    <dd>
    Not implemented: use <code>pairs(node)</code> or <code>node:__pairs()</code> instead.
 See alternative usage below.
 This is not implemented because
 Lua >=5.3 implements ipairs via <code>__index()</code>.
 This would mean that <code>__index()</code> would have to treat integer subscript lookup specially, so:</p>

<ul>
    <li>Although <code>node[&apos;abc&apos;]</code>  => produces a new node so that <code>node.abc.def.ghi</code> works.</li>
    <li><code>node[1]</code>  => would have to produce value <code>node(1).__</code> so ipairs() works. <br>
    Since ipairs() will be little used anyway, the consequent inconsistency discourages implementation.</li>
</ul>

<p> Alternatives using <code>pairs()</code> are as follows:

    </ul>





    <h3>Examples:</h3>
    <ul>
        <li><pre class="example"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(node) <span class="keyword">do</span>   <span class="keyword">if</span> <span class="keyword">not</span> <span class="global">tonumber</span>(k) <span class="keyword">break</span> <span class="keyword">end</span>   &lt;do_your_stuff with k,v&gt;   <span class="keyword">end</span>
 <span class="comment">-- this works since M sorts numbers first by default. The order may be changed by specifying a non-default collation on the database</span></pre></li>
        <li><pre class="example"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">1</span>/<span class="number">0</span> <span class="keyword">do</span>   v=node[i].__  <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">break</span> <span class="keyword">then</span>   &lt;do_your_stuff with k,v&gt;   <span class="keyword">end</span>
 <span class="comment">-- alternative that ensures integer keys</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node:__pairs"></a>
    <strong>node:__pairs ([reverse])</strong>
    </dt>
    <dd>

<p>Implement <code>pairs()</code> by iterating over the children of a given node.
 At each child, yielding the triplet: subnode, subnode value (or <code>nil</code>), and subscript
 You can use either <code>pairs(node)</code> or <code>node:pairs()</code>.
 If you need to iterate in reverse (or in Lua 5.1), use node:pairs(reverse) instead of pairs(node).</p>

<p> <em>Caution:</em> for the sake of speed, the iterator supplies a <em>mutable</em> node. This means it can
 re-use the same node for each iteration by changing its last subscript, making it faster.
 But if your loop needs to retain a reference to the node after loop iteration, it should create
 an immutable copy of that node using <code>ydb.node(node)</code>.
 Mutability can be tested for using <code>node:ismutable()</code></p>

<p> <em>Notes:</em></p>

<ul>
    <li><code>pairs()</code> order is guaranteed to equal the M collation sequence order
    (even though <code>pairs()</code> order is not normally guaranteed for Lua tables).
    This means that <code>pairs()</code> is a reasonable substitute for ipairs which is not implemented.</li>
    <li>This is very slightly slower than <code>node:subscripts()</code> which only iterates subscript names without
    fetching the node value.</li>
</ul>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         Boolean flag iterates in reverse if true
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        3 value: subnode<em>object, subnode</em>value<em>or</em>nil, subscript
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:subscripts">node:subscripts</a>
    </ul>

    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="keyword">for</span> subnode,value[,subscript] <span class="keyword">in</span> <span class="global">pairs</span>(node) <span class="keyword">do</span>  subnode:incr(value)  <span class="keyword">end</span>
 <span class="comment">-- to double the values of all subnodes of node</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "node:delete_tree"></a>
    <strong>node:delete_tree ()</strong>
    </dt>
    <dd>
    Delete database tree pointed to by node object.

    </ul>




    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#delete_tree">delete_tree</a>
    </ul>


</dd>
    <dt>
    <a name = "node:dump"></a>
    <strong>node:dump ([maxlines=30])</strong>
    </dt>
    <dd>
    Dump the specified node tree.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">maxlines</span>
         Maximum number of lines to output before stopping dump
         (<em>default</em> 30)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        dump as a string
    </ol>




</dd>
    <dt>
    <a name = "node:get"></a>
    <strong>node:get ([default])</strong>
    </dt>
    <dd>
    Get <a href="yottadb.html#node">node</a>'s value.
 Equivalent to <code>node.__</code>, but 2.5x slower.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">default</span>
         specify the value to return if the node has no data; if not supplied, <code>nil</code> is the default
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        value of the node
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#get">get</a>
    </ul>


</dd>
    <dt>
    <a name = "node:gettree"></a>
    <strong>node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</strong>
    </dt>
    <dd>

<p>Fetch database node and subtree and return a Lua table of it. </p>

<p> <em>Notes:</em></p>

<ul>
    <li>special field name <code>__</code> in the returned table indicates the value of the node itself.</li>
    <li>Lua tables do not preserve the order YDB subtrees.</li>
</ul>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">maxdepth</span>
         subscript depth to fetch. (<code>nil</code>=infinite depth; 1 fetches first layer of subscript's values only)
         (<em>optional</em>)
        </li>
        <li><span class="parameter">filter</span>

<p> is either <code>nil</code> or a function matching the prototype <code>function(node, node_top_subscript_name, value, recurse, depth)</code></p>

<ul>
    <li>If filter is <code>nil</code>, all values are fetched unfiltered.</li>
    <li>If filter is a function it is invoked on every subscript
    to allow it to cast/alter every value and recurse flag;
    note that at node root (depth=0), subscript passed to filter is the empty string ""</li>
    <li>Filter may optionally return two items: <code>value</code> and <code>recurse</code>, which must either be the input parameters <code>value</code> and <code>recurse</code> or may be altered:
    <ul>
        <li>If filter returns <code>value</code> then <code>gettree()</code> will store it in the table for that database subscript/value; or store nothing if <code>value=nil</code>.</li>
        <li>If filter returns <code>recurse=false</code>, it will prevent recursion deeper into that particular subscript. If it returns <code>nil</code>, it will use the original value of recurse.</li>
    </ul></li>
</ul>

         (<em>optional</em>)
        </li>
        <li><span class="parameter">_value</span>
         For internal use only (to avoid duplicate value fetches, for speed).
         (<em>optional</em>)
        </li>
        <li><span class="parameter">_depth</span>
         For internal use only (to record depth of recursion) and must start unspecified (nil).
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Lua table containing data
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:settree">settree</a>
    </ul>

    <h3>Example:</h3>
    <ul>
        <pre class="example">n=ydb.node(<span class="string">'^oaks'</span>)
n:settree({__=<span class="string">'treedata'</span>, {shadow=<span class="number">10</span>,angle=<span class="number">30</span>}, {shadow=<span class="number">13</span>,angle=<span class="number">30</span>}})
n:gettree(<span class="keyword">nil</span>, <span class="global">print</span>)
<span class="comment">-- ^oaks		treedata	true	0
</span><span class="comment">-- ^oaks(1)	1	nil	true	1
</span><span class="comment">-- ^oaks(1,"angle")	angle	30	false	2
</span><span class="comment">-- ^oaks(1,"shadow")	shadow	10	false	2
</span><span class="comment">-- ^oaks(2)	2	nil	true	1
</span><span class="comment">-- ^oaks(2,"angle")	angle	30	false	2
</span><span class="comment">-- ^oaks(2,"shadow")	shadow	13	false	2
</span>
<span class="comment">-- now fetch the tree into a Lua table
</span>tbl = n:gettree()</pre>
    </ul>

</dd>
    <dt>
    <a name = "node:incr"></a>
    <strong>node:incr ([increment=1])</strong>
    </dt>
    <dd>
    Increment <a href="yottadb.html#node">node</a>'s value.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">increment</span>
         Amount to increment by (negative to decrement)
         (<em>default</em> 1)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the new value
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#incr">incr</a>
    </ul>


</dd>
    <dt>
    <a name = "node:lock"></a>
    <strong>node:lock ([timeout])</strong>
    </dt>
    <dd>
    Releases all locks held and attempts to acquire a lock matching this node.
 Returns after <code>timeout</code>, if specified.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         Integer timeout in seconds to wait for the lock.
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#lock">lock</a>
    </ul>


</dd>
    <dt>
    <a name = "node:lock_decr"></a>
    <strong>node:lock_decr ()</strong>
    </dt>
    <dd>
    Decrements a lock matching this node, releasing it if possible.

    </ul>




    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#lock_decr">lock_decr</a>
    </ul>


</dd>
    <dt>
    <a name = "node:lock_incr"></a>
    <strong>node:lock_incr ([timeout])</strong>
    </dt>
    <dd>
    Attempts to acquire or increment a lock matching this node.
 Returns after <code>timeout</code>, if specified.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         Integer timeout in seconds to wait for the lock.
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#lock_incr">lock_incr</a>
    </ul>


</dd>
    <dt>
    <a name = "node:set"></a>
    <strong>node:set (value)</strong>
    </dt>
    <dd>
    Set <a href="yottadb.html#node">node</a>'s value.
 Equivalent to <code>node.__ = x</code>, but 4x slower.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         New value or <code>nil</code> to delete node
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#set">set</a>
    </ul>


</dd>
    <dt>
    <a name = "node:settree"></a>
    <strong>node:settree (tbl[, filter[, _seen]])</strong>
    </dt>
    <dd>

<p>Populate database from a table.
 In its simplest form:</p>
<pre><code>n=ydb.node('var')
n:settree({__='berwyn', weight=78, ['!@#$']='junk', appearance={__='handsome', eyes='blue', hair='blond'}, age=yottadb.DELETE})
</code></pre>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">tbl</span>

<p> The table to store into the database:</p>

<ul>
    <li>Special field name <code>tbl.__</code> sets the value of the node itself, as opposed to a subnode.</li>
    <li>Set any table value to <code>yottadb.DELETE</code> to have <code>settree()</code> delete the value of the associated database node. You cannot delete the whole subtree.</li>
</ul>

        </li>
        <li><span class="parameter">filter</span>

<p> Function of the form function(node, key, value) or <code>nil</code></p>

<ul>
    <li>If filter is <code>nil</code>, all values are set unfiltered.</li>
    <li>If filter is a function(node, key, value) it is invoked on every node
    to allow it to cast/alter every key name and value.</li>
    <li>Filter must return the same or altered: key, value.</li>
    <li>Type errors can be handled (or ignored) using this function, too.</li>
    <li>If filter returns <code>yottadb.DELETE</code> as value, the key is deleted.</li>
    <li>If filter returns <code>nil</code> as key or value, <code>settree()</code> will simply not update the current database value.</li>
</ul>

         (<em>optional</em>)
        </li>
        <li><span class="parameter">_seen</span>
         For internal use only (to prevent accidental duplicate sets: bad because order setting is not guaranteed).
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Examples:</h3>
    <ul>
        <li><pre class="example">n=ydb.node(<span class="string">'^oaks'</span>)
n:settree({__=<span class="string">'treedata'</span>, {shadow=<span class="number">10</span>,angle=<span class="number">30</span>}, {shadow=<span class="number">13</span>,angle=<span class="number">30</span>}})
n:dump()</pre></li>
        <li><pre class="example"><span class="comment">-- outputs:
</span>^oaks=<span class="string">"treedata"</span>
^oaks(<span class="string">"1"</span>,<span class="string">"angle"</span>)=<span class="string">"30"</span>
^oaks(<span class="string">"1"</span>,<span class="string">"shadow"</span>)=<span class="string">"10"</span>
^oaks(<span class="string">"2"</span>,<span class="string">"angle"</span>)=<span class="string">"30"</span>
^oaks(<span class="string">"2"</span>,<span class="string">"shadow"</span>)=<span class="string">"13"</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node:subscripts"></a>
    <strong>node:subscripts ([reverse])</strong>
    </dt>
    <dd>
    Return iterator over the <em>child</em> subscript names of a node (in M terms, collate from "" to "").
 Unlike <code>yottadb.subscripts()</code>, <code>node:subscripts()</code> returns all <em>child</em> subscripts, not subsequent <em>sibling</em> subscripts in the same level. <br>
 Very slightly faster than node:__pairs() because it iterates subscript names without fetching the node value. <br>
 Note that <code>subscripts()</code> order is guaranteed to equal the M collation sequence.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         set to true to iterate in reverse order
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        iterator over <em>child</em> subscript names of a node, which returns a sequence of subscript name strings
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:__pairs">node:__pairs</a>
    </ul>

    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="keyword">for</span> subscript <span class="keyword">in</span> node:subscripts() <span class="keyword">do</span>  <span class="global">print</span> subscript  <span class="keyword">end</span></pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Node_properties"></a>Node properties </h2>

    <dl class="function">
    <dt>
    <a name = "node:data"></a>
    <strong>node:data ()</strong>
    </dt>
    <dd>
    Fetch the 'data' flags of the node @see data.

    </ul>






</dd>
    <dt>
    <a name = "node:depth"></a>
    <strong>node:depth ()</strong>
    </dt>
    <dd>
    Fetch the depth of the node, i.e.  how many subscripts it has.

    </ul>






</dd>
    <dt>
    <a name = "node:has_tree"></a>
    <strong>node:has_tree ()</strong>
    </dt>
    <dd>
    Return true if the node has a tree; otherwise false.

    </ul>






</dd>
    <dt>
    <a name = "node:has_value"></a>
    <strong>node:has_value ()</strong>
    </dt>
    <dd>
    Return true if the node has a value; otherwise false.

    </ul>






</dd>
    <dt>
    <a name = "node:ismutable"></a>
    <strong>node:ismutable ()</strong>
    </dt>
    <dd>
    Return true if the node is mutable; otherwise false.

    </ul>






</dd>
    <dt>
    <a name = "node:name"></a>
    <strong>node:name ()</strong>
    </dt>
    <dd>
    Fetch the name of the node, i.e.  the rightmost subscript.

    </ul>






</dd>
    <dt>
    <a name = "node:subsarray"></a>
    <strong>node:subsarray ()</strong>
    </dt>
    <dd>
    Return <a href="yottadb.html#node">node</a>'s subsarray of subscript strings as a table.

    </ul>






</dd>
    <dt>
    <a name = "node:varname"></a>
    <strong>node:varname ()</strong>
    </dt>
    <dd>
    Fetch the varname of the node, i.e.  the leftmost subscript.

    </ul>






</dd>
</dl>
    <h2 class="section-header "><a name="Class_key"></a>Class key </h2>

    <dl class="function">
    <dt>
    <a name = "key"></a>
    <strong>key (varname[, subsarray])</strong>
    </dt>
    <dd>

<p>Creates an object that represents a YDB node; deprecated after v0.1.  <br>
 <code>key()</code> is a subclass of <code>node()</code> designed to implement deprecated
 property names for backward compatibility, as follows:</p>

<ul>
    <li><a href="yottadb.html#node:name">name</a> (this node's subscript or variable name)</li>
    <li><code>value</code> (this node's value in the YottaDB database)</li>
    <li><a href="yottadb.html#data">data</a> (see <code>data()</code>)</li>
    <li><a href="yottadb.html#node:has_value">has_value</a> (whether or not this node has a value)</li>
    <li><a href="yottadb.html#node:has_tree">has_tree</a> (whether or not this node has a subtree)</li>
    <li><code>__varname</code> database variable name string -- for compatibility with a previous version</li>
    <li><code>__subsarray</code> table array of database subscript name strings -- for compatibility with a previous version
    and deprecated definitions of <code>key:subscript()</code>, <code>key:subscript_next()</code>, <code>key:subscript_previous()</code> <br></li>
</ul>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String variable name.
        </li>
        <li><span class="parameter">subsarray</span>
         list of subscripts or table subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        key object of the specified node with metatable <code>yottadb._key</code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node">node</a>
    </ul>


</dd>
    <dt>
    <a name = "key._property_"></a>
    <strong>key._property_</strong>
    </dt>
    <dd>
    Properties of key object that are accessed with a dot.
 These properties, listed below, are unlike object methods, which are accessed with a colon.
 This kind of property access is for backward compatibility.</p>

<p> For example, access data property with: <code>key.data</code>

    </ul>

    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">name</span>
         equivalent to <code>node:name()</code>
        </li>
        <li><span class="parameter">data</span>
         equivalent to <code>node:data()</code>
        </li>
        <li><span class="parameter">has_value</span>
         equivalent to <code>node:has_value()</code>
        </li>
        <li><span class="parameter">has_tree</span>
         equivalent to <code>node:has_tree()</code>
        </li>
        <li><span class="parameter">value</span>
         equivalent to <code>node.__</code>
        </li>
        <li><span class="parameter">__varname</span>
         database variable name string -- for compatibility with a previous version
        </li>
        <li><span class="parameter">__subsarray</span>
         table array of database subscript name strings -- for compatibility with a previous version
        </li>
    </ul>





</dd>
    <dt>
    <a name = "key:delete_node"></a>
    <strong>key:delete_node ()</strong>
    </dt>
    <dd>
    Deprecated way to delete database node value pointed to by node object.
 Prefer <code>node:set(nil)</code>

    </ul>




    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#delete_node">delete_node</a></li>
         <li><a href="yottadb.html#set">set</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscript_next"></a>
    <strong>key:subscript_next ([reset[, reverse]])</strong>
    </dt>
    <dd>

<p>Deprecated way to get next <em>sibling</em> subscript. </p>

<p> <em>Note:</em> this starts from the given location and gives the next <em>sibling</em> subscript in the M collation sequence.
 It operates differently than <code>node:subscipts()</code> which yields all subscripts that are <em>children</em> of the given node.
 Deprecated because:</p>

<ul>
    <li>It keeps dangerous state in the object: causes bugs where old references to it think it's still original.</li>
    <li>It is more Lua-esque to iterate all subscripts in the node (think table) using <code>pairs()</code>.</li>
    <li>If sibling access becomes a common use-case, it should be reimplemented as an iterator.</li>
</ul>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reset</span>
         If <code>true</code>, resets to the original subscript before any calls to <code>subscript_next()</code>
         (<em>optional</em>)
        </li>
        <li><span class="parameter">reverse</span>
         If <code>true</code> then get previous instead of next
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#node:__pairs">node:__pairs</a></li>
         <li><a href="yottadb.html#subscript_previous">subscript_previous</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscript_previous"></a>
    <strong>key:subscript_previous ([reset])</strong>
    </dt>
    <dd>
    Deprecated way to get previous <em>sibling</em> subscript.
 See notes for <code>subscript_previous()</code>

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reset</span>
         If <code>true</code>, resets to the original subscript before any calls to <code>subscript_next()</code>
 or <code>subscript_previous()</code>
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#node:__pairs">node:__pairs</a></li>
         <li><a href="yottadb.html#subscript_next">subscript_next</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscripts"></a>
    <strong>key:subscripts ([reverse])</strong>
    </dt>
    <dd>

<p>Deprecated way to get same-level subscripts from this node onward.
 Deprecated because:</p>

<ul>
    <li><code>pairs()</code> is more Lua-esque.</li>
    <li>It was non-intuitive that <code>key:subscripts()</code> iterates only subsequent subscripts, not all child subscripts.</li>
</ul>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         When set to <code>true</code>, iterates in reverse
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#subscripts">subscripts</a>
    </ul>


</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-07-11 14:41:46 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
