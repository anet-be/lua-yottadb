<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>lua-yottadb</h1>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>yottadb</strong></li>
</ul>
<h2>Contents</h2>
<ul>
<li><a href=""><b>Summary</b></a></li>
<br/>
<li><a href="#Basic_low_level_functions"><b>Basic low level functions </b></a></li>
    <li><a href="#block_M_signals">block_M_signals (bool)</a></li>
    <li><a href="#data">data (varname[, subsarray[, ...]])</a></li>
    <li><a href="#delete_node">delete_node (varname[, subsarray[, ...]])  [deprecated v3.0]:</a></li>
    <li><a href="#delete_tree">delete_tree (varname[, subsarray[, ...]])  [deprecated v3.0]:</a></li>
    <li><a href="#get">get (varname[, subsarray[, ...]])</a></li>
    <li><a href="#get_error_code">get_error_code (message)</a></li>
    <li><a href="#grab">grab (varname[, subsarray[, ...[, timeout]]])</a></li>
    <li><a href="#incr">incr (varname[, subsarray][, ...], increment)</a></li>
    <li><a href="#init">init ([signal_blocker])</a></li>
    <li><a href="#kill">kill (varname[, subsarray[, ...]])</a></li>
    <li><a href="#lock">lock ([nodes[, timeout]])</a></li>
    <li><a href="#lock_decr">lock_decr (varname[, subsarray[, ...]])</a></li>
    <li><a href="#lock_incr">lock_incr (varname[, subsarray[, ...[, timeout]]])</a></li>
    <li><a href="#node_next">node_next (varname[, subsarray[, ...]])</a></li>
    <li><a href="#node_previous">node_previous (varname[, subsarray[, ...]])</a></li>
    <li><a href="#release">release (varname[, subsarray[, ...]])</a></li>
    <li><a href="#set">set (varname[, subsarray][, ...], value)</a></li>
    <li><a href="#str2zwr">str2zwr (s)</a></li>
    <li><a href="#subscript_next">subscript_next (varname[, subsarray[, ...]])</a></li>
    <li><a href="#subscript_previous">subscript_previous (varname[, subsarray[, ...]])</a></li>
    <li><a href="#subscripts">subscripts (varname[, subsarray[, ...[, reverse]]])</a></li>
    <li><a href="#ydb_eintr_handler">ydb_eintr_handler ()</a></li>
    <li><a href="#zwr2str">zwr2str (s)</a></li>
<br/>
<li><a href="#Transactions"><b>Transactions </b></a></li>
    <li><a href="#tp">tp ([id][, varnames], f[, ...])</a></li>
    <li><a href="#transaction">transaction ([id][, varnames], f)</a></li>
    <li><a href="#trestart">trestart ()</a></li>
    <li><a href="#trollback">trollback ()</a></li>
<br/>
<li><a href="#High_level_functions"><b>High level functions </b></a></li>
    <li><a href="#dump">dump (node[, ...[, maxlines=30]])</a></li>
    <li><a href="#require">require (Mprototypes)</a></li>
<br/>
<li><a href="#Node_class_operations"><b>Node class operations </b></a></li>
    <li><a href="#inherit">inherit (node_func[, metatable])</a></li>
    <li><a href="#isnode">isnode (object)</a></li>
    <li><a href="#node">node (varname[, subsarray][, ...], node)</a></li>
<br/>
<li><a href="#Node_class"><b>Node class </b></a></li>
    <li><a href="#node:__ipairs">node:__ipairs ()</a></li>
    <li><a href="#node:__pairs">node:__pairs ([reverse])</a></li>
    <li><a href="#node:__repr">node:__repr ()</a></li>
    <li><a href="#node:delete_tree">node:delete_tree ()  [deprecated v3.0]:</a></li>
    <li><a href="#node:dump">node:dump ([maxlines=30])</a></li>
    <li><a href="#node:get">node:get ([default])</a></li>
    <li><a href="#node:gettree">node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</a></li>
    <li><a href="#node:grab">node:grab ([timeout])</a></li>
    <li><a href="#node:incr">node:incr ([increment=1])</a></li>
    <li><a href="#node:kill">node:kill ()</a></li>
    <li><a href="#node:lock">node:lock ([timeout])</a></li>
    <li><a href="#node:lock_decr">node:lock_decr ()</a></li>
    <li><a href="#node:lock_incr">node:lock_incr ([timeout])</a></li>
    <li><a href="#node:release">node:release ()</a></li>
    <li><a href="#node:set">node:set (value)</a></li>
    <li><a href="#node:settree">node:settree (tbl[, filter[, _seen]])</a></li>
    <li><a href="#node:subscripts">node:subscripts ([reverse])</a></li>
<br/>
<li><a href="#Node_class_properties"><b>Node class properties </b></a></li>
    <li><a href="#node:data">node:data ()</a></li>
    <li><a href="#node:depth">node:depth ()</a></li>
    <li><a href="#node:has_tree">node:has_tree ()</a></li>
    <li><a href="#node:has_value">node:has_value ()</a></li>
    <li><a href="#node:ismutable">node:ismutable ()</a></li>
    <li><a href="#node:name">node:name ()</a></li>
    <li><a href="#node:subsarray">node:subsarray ()</a></li>
    <li><a href="#node:varname">node:varname ()</a></li>
<br/>
<li><a href="#Key_class"><b>Key class </b></a></li>
    <li><a href="#_property_">_property_  [deprecated v1.0]:</a></li>
    <li><a href="#key">key (varname[, subsarray])  [deprecated v1.0]:</a></li>
    <li><a href="#key:delete_node">key:delete_node ()  [deprecated v1.0]:</a></li>
    <li><a href="#key:subscript_next">key:subscript_next ([reset[, reverse]])  [deprecated v1.0]:</a></li>
    <li><a href="#key:subscript_previous">key:subscript_previous ([reset])  [deprecated v1.0]:</a></li>
    <li><a href="#key:subscripts">key:subscripts ([reverse])  [deprecated v1.0]:</a></li>


</ul>



</div>

<div id="content">

<h1>Module <code>yottadb</code></h1>
<p>Lua-bindings for YottaDB, sponsored by the <a href="https://www.uantwerpen.be/en/library/">University of Antwerp Library</a>.</p>
<p> See <a href="https://github.com/anet-be/lua-yottadb/blob/master/README.md">README</a> for a quick introduction with examples. <br>
 Home page: <a href="https://github.com/anet-be/lua-yottadb/">https://github.com/anet-be/lua-yottadb/</a></p>


<h2><a href="#Basic_low_level_functions">Basic low level functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#block_M_signals">block_M_signals (bool)</a></td>
	<td class="summary">Block or unblock YDB signals while M code is running.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#data">data (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Return whether a node has a value or subtree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delete_node">delete_node (varname[, subsarray[, ...]])  [deprecated v3.0]:</a></td>
	<td class="summary">Deprecated and replaced by <code>set(varname[, subsarray[, ...]], nil)</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delete_tree">delete_tree (varname[, subsarray[, ...]])  [deprecated v3.0]:</a></td>
	<td class="summary">Deprecated and replaced by kill.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get">get (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Gets and returns the value of a database variable or node; or <code>nil</code> if the variable or node does not exist.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_error_code">get_error_code (message)</a></td>
	<td class="summary">Get the YDB error code (if any) contained in the given error message.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grab">grab (varname[, subsarray[, ...[, timeout]]])</a></td>
	<td class="summary">Alias for lock_incr to acquire or increment a lock named varname[(subsarray)].</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#incr">incr (varname[, subsarray][, ...], increment)</a></td>
	<td class="summary">Increments the numeric value of a database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#init">init ([signal_blocker])</a></td>
	<td class="summary">Initialize ydb and set blocking of M signals.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#kill">kill (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Deletes a database variable tree (node and subnodes) or a node subtree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock">lock ([nodes[, timeout]])</a></td>
	<td class="summary">Releases all locks held and attempts to acquire all requested locks.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock_decr">lock_decr (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Decrements a lock of the same name as varname[(subsarray)], releasing it if zero.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lock_incr">lock_incr (varname[, subsarray[, ...[, timeout]]])</a></td>
	<td class="summary">Attempts to acquire or increment a lock named varname[(subsarray)].</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node_next">node_next (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the full subscript list of the next node after a database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node_previous">node_previous (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the full subscript list of the previous node after a database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#release">release (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Alias for lock_decr to decrement a lock of the same name as varname[(subsarray)], releasing it if zero.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set">set (varname[, subsarray][, ...], value)</a></td>
	<td class="summary">Sets the value of a database variable or node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#str2zwr">str2zwr (s)</a></td>
	<td class="summary">Returns the zwrite-formatted version of the given string.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscript_next">subscript_next (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the next subscript for a database variable or node; or <code>nil</code> if there isn't one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscript_previous">subscript_previous (varname[, subsarray[, ...]])</a></td>
	<td class="summary">Returns the previous subscript for a database variable or node; or <code>nil</code> if there isn't one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subscripts">subscripts (varname[, subsarray[, ...[, reverse]]])</a></td>
	<td class="summary">Returns an iterator for iterating over database <em>sibling</em> subscripts starting from the node referenced by <a href="yottadb.html#node:varname">varname</a> and <code>subarray</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ydb_eintr_handler">ydb_eintr_handler ()</a></td>
	<td class="summary">Lua function to call <code>ydb_eintr_handler()</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#zwr2str">zwr2str (s)</a></td>
	<td class="summary">Returns the string described by the given zwrite-formatted string.</td>
	</tr>
</table>
<h2><a href="#Transactions">Transactions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#tp">tp ([id][, varnames], f[, ...])</a></td>
	<td class="summary">Initiates a transaction (low level function).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#transaction">transaction ([id][, varnames], f)</a></td>
	<td class="summary">Returns a high-level transaction-safe version of the given function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#trestart">trestart ()</a></td>
	<td class="summary">Make the currently running transaction function restart immediately.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#trollback">trollback ()</a></td>
	<td class="summary">Make the currently running transaction function rollback immediately with a YDB<em>TP</em>ROLLBACK error.</td>
	</tr>
</table>
<h2><a href="#High_level_functions">High level functions </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#dump">dump (node[, ...[, maxlines=30]])</a></td>
	<td class="summary">Dump the specified node tree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#require">require (Mprototypes)</a></td>
	<td class="summary">Import M routines as Lua functions specified in ydb 'call-in' file.</td>
	</tr>
</table>
<h2><a href="#Node_class_operations">Node class operations </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#inherit">inherit (node_func[, metatable])</a></td>
	<td class="summary">Create a new node class that inherits from the yottadb.node superclass.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#isnode">isnode (object)</a></td>
	<td class="summary">Tests whether object is a node object or inherits from a node object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node">node (varname[, subsarray][, ...], node)</a></td>
	<td class="summary">Creates an object that represents a YottaDB node.</td>
	</tr>
</table>
<h2><a href="#Node_class">Node class </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#node:__ipairs">node:__ipairs ()</a></td>
	<td class="summary">Not implemented: use <code>pairs(node)</code> or <code>node:__pairs()</code> instead.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:__pairs">node:__pairs ([reverse])</a></td>
	<td class="summary">Implement <code>pairs()</code> by iterating over the children of a given node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:__repr">node:__repr ()</a></td>
	<td class="summary">Return raw representation of node's unique memory address.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:delete_tree">node:delete_tree ()  [deprecated v3.0]:</a></td>
	<td class="summary">Deprecated and replaced by kill.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:dump">node:dump ([maxlines=30])</a></td>
	<td class="summary">Dump the specified node tree.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:get">node:get ([default])</a></td>
	<td class="summary">Get <a href="yottadb.html#node">node</a>'s value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:gettree">node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</a></td>
	<td class="summary">Fetch database node and subtree and return a Lua table of it.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:grab">node:grab ([timeout])</a></td>
	<td class="summary">Alias for node:lock_incr to acquire or increment a lock matching this node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:incr">node:incr ([increment=1])</a></td>
	<td class="summary">Increment <a href="yottadb.html#node">node</a>'s value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:kill">node:kill ()</a></td>
	<td class="summary">Delete database tree (node and subnodes) pointed to by node object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock">node:lock ([timeout])</a></td>
	<td class="summary">Releases all locks held and attempts to acquire a lock matching only this node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock_decr">node:lock_decr ()</a></td>
	<td class="summary">Decrements a lock matching this node, releasing it if zero.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:lock_incr">node:lock_incr ([timeout])</a></td>
	<td class="summary">Attempts to acquire or increment a lock matching this node.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:release">node:release ()</a></td>
	<td class="summary">Alias for node:lock_decr to decrement a lock matching this node, releasing it if zero.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:set">node:set (value)</a></td>
	<td class="summary">Set <a href="yottadb.html#node">node</a>'s value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:settree">node:settree (tbl[, filter[, _seen]])</a></td>
	<td class="summary">Populate database from a table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:subscripts">node:subscripts ([reverse])</a></td>
	<td class="summary">Return iterator over the <em>child</em> subscript names of a node (in M terms, collate from "" to "").</td>
	</tr>
</table>
<h2><a href="#Node_class_properties">Node class properties </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#node:data">node:data ()</a></td>
	<td class="summary">Fetch the 'data' bitfield of the node that describes whether the node has a data value or subtrees.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:depth">node:depth ()</a></td>
	<td class="summary">Fetch the depth of the node: how many subscripts it has.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:has_tree">node:has_tree ()</a></td>
	<td class="summary">Return true if the node has a tree; otherwise false.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:has_value">node:has_value ()</a></td>
	<td class="summary">Return true if the node has a value; otherwise false.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:ismutable">node:ismutable ()</a></td>
	<td class="summary">Return true if the node is mutable; otherwise false.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:name">node:name ()</a></td>
	<td class="summary">Fetch the name of the node: the rightmost subscript.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:subsarray">node:subsarray ()</a></td>
	<td class="summary">Return <a href="yottadb.html#node">node</a>'s subsarray of subscript strings as a table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#node:varname">node:varname ()</a></td>
	<td class="summary">Fetch the varname of the node: the leftmost subscript.</td>
	</tr>
</table>
<h2><a href="#Key_class">Key class </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#_property_">_property_  [deprecated v1.0]:</a></td>
	<td class="summary">Properties of key object that are accessed with a dot.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key">key (varname[, subsarray])  [deprecated v1.0]:</a></td>
	<td class="summary">Creates an object that represents a YDB node; deprecated after v0.1.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:delete_node">key:delete_node ()  [deprecated v1.0]:</a></td>
	<td class="summary">Deprecated way to delete database node value pointed to by node object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscript_next">key:subscript_next ([reset[, reverse]])  [deprecated v1.0]:</a></td>
	<td class="summary">Deprecated way to get next <em>sibling</em> subscript.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscript_previous">key:subscript_previous ([reset])  [deprecated v1.0]:</a></td>
	<td class="summary">Deprecated way to get previous <em>sibling</em> subscript.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#key:subscripts">key:subscripts ([reverse])  [deprecated v1.0]:</a></td>
	<td class="summary">Deprecated way to get same-level subscripts from this node onward.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Basic_low_level_functions"></a>Basic low level functions </h2>

    <dl class="function">
    <dt>
    <a name = "block_M_signals"></a>
    <strong>block_M_signals (bool)</strong>
    </dt>
    <dd>
    Block or unblock YDB signals while M code is running.
 This function is designed to be passed as a callback to yottadb.init() as the <code>signal_blocker</code> parameter.
 The function accepts one boolean parameter: <code>true</code> for entering Lua and <code>false</code> for exiting Lua:</p>

<ul>
    <li>When <code>true</code> is passed to this function it blocks all the signals listed in <code>BLOCKED_SIGNALS</code> in <code>callins.c</code>
    using OS call <code>sigprocmask()</code>. <code>SIGALRM</code> is treated specially: instead of being blocked OS call sigaction()
    is used to set the <code>SA_RESTART</code> flag for <code>SIGALRM</code>. This makes the OS automatically restart IO calls that are
    interrupted by <code>SIGALRM</code>. The benefit of this over blocking is that the YottaDB <code>SIGALRM</code> handler does
    actually run, even during Lua code, allowing YottaDB to flush the database or IO as necessary (otherwise
    M code would need to run the M command <code>VIEW &quot;FLUSH&quot;</code> after calling Lua code).</li>
    <li>When <code>false</code> is passed to this function it will reverse the effect, unblocking and clearing <code>SA_RESTART</code> for
    the same signals manipulated when <code>true</code> is passed.</li>
</ul>

<p> <em>Note:</em> This function does take time, as OS calls are slow. Using it will increase the M calling overhead
 by a factor of 2-5 times the bare calling overhead (on the order of 1.4 microseconds on a typical
 2020s x86_64 CPU; see <code>make benchmarks</code>)

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bool</span>
         true to block; false to unblock YottaDB signals
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        nothing
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#init">init</a>
    </ul>


</dd>
    <dt>
    <a name = "data"></a>
    <strong>data (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Return whether a node has a value or subtree.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        0: (node has neither value nor subtree)</li>
        <li>
        1: node has value, not subtree</li>
        <li>
        10: node has no value, but does have a subtree</li>
        <li>
        11: node has both value and subtree</li>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="comment">-- include setup from example at yottadb.set()
</span>ydb.data(<span class="string">'^Population'</span>)
<span class="comment">-- 10.0
</span>ydb.data(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
<span class="comment">-- 11.0</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "delete_node"></a>
    <strong>delete_node (varname[, subsarray[, ...]])  [deprecated v3.0]:</strong>
    </dt>
    <dd>
    Deprecated and replaced by <code>set(varname[, subsarray[, ...]], nil)</code>.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>}, <span class="number">1367000</span>)
ydb.delete_node(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>})  <span class="comment">-- or ydb.set('^Population', {'Belgium'}, nil)
</span>ydb.get(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>})
<span class="comment">-- nil</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "delete_tree"></a>
    <strong>delete_tree (varname[, subsarray[, ...]])  [deprecated v3.0]:</strong>
    </dt>
    <dd>
    Deprecated and replaced by kill.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#kill">kill</a>
    </ul>


</dd>
    <dt>
    <a name = "get"></a>
    <strong>get (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Gets and returns the value of a database variable or node; or <code>nil</code> if the variable or node does not exist.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string value or <code>nil</code>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="comment">-- include setup from example at yottadb.set()
</span>ydb.get(<span class="string">'^Population'</span>)
<span class="comment">-- nil
</span>ydb.get(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>})
<span class="comment">-- 1367000
</span>ydb.get(<span class="string">'$zgbldir'</span>)
<span class="comment">-- /home/ydbuser/.yottadb/r1.34_x86_64/g/yottadb.gld</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "get_error_code"></a>
    <strong>get_error_code (message)</strong>
    </dt>
    <dd>
    Get the YDB error code (if any) contained in the given error message.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">message</span>
         String error message.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        the YDB error code (if any) for the given error message,</li>
        <li>
        or <code>nil</code> if the message is not a YDB error.</li>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
ydb.get_error_code(<span class="string">'YDB Error: -150374122: %YDB-E-ZGBLDIRACC, Cannot access global directory !AD!AD!AD.'</span>)
<span class="comment">-- -150374122</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "grab"></a>
    <strong>grab (varname[, subsarray[, ...[, timeout]]])</strong>
    </dt>
    <dd>
    Alias for lock_incr to acquire or increment a lock named varname[(subsarray)].
 Returns after <code>timeout</code>, if specified.
 Raises a <code>yottadb.YDB_LOCK_TIMEOUT</code> error if lock could not be acquired.</p>

<p> If timeout is not supplied or is <code>nil</code>, wait forever; timeout of zero means try only once.
 <em>Caution:</em> timeout is <em>not</em> optional if <code>...</code> list of subscripts is provided, but it may be <code>nil</code>.
 Otherwise lock_incr cannot tell whether it is a subscript or a timeout.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         Number timeout in seconds to wait for the lock.
  Optional only if subscripts is a table.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#lock_incr">lock_incr</a></li>
         <li><a href="yottadb.html#release">release</a></li>
    </ul>


</dd>
    <dt>
    <a name = "incr"></a>
    <strong>incr (varname[, subsarray][, ...], increment)</strong>
    </dt>
    <dd>
    Increments the numeric value of a database variable or node.
 Raises an error on overflow.</p>

<p> <em>Caution:</em> increment is <em>not</em> optional if <code>...</code> list of subscript is provided.
 Otherwise incr() cannot tell whether last parameter is a subscript or an increment.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">increment</span>
         Number or string amount to increment by (default=1)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the new value
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
ydb.get(<span class="string">'num'</span>)
<span class="comment">-- 4
</span>ydb.incr(<span class="string">'num'</span>, <span class="number">3</span>)
<span class="comment">-- 7
</span>ydb.incr(<span class="string">'num'</span>)
<span class="comment">-- 8</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "init"></a>
    <strong>init ([signal_blocker])</strong>
    </dt>
    <dd>
    Initialize ydb and set blocking of M signals.
 If <code>signal_blocker</code> is specified, block M signals which could otherwise interrupt slow IO operations like reading from stdin or a pipe.
 Raise any errors.
 See also the notes on signals in the <a href="https://github.com/anet-be/lua-yottadb#signals--eintr-errors">README</a>.</p>

<p> <em>Note:</em> any calls to the YDB API also initialize YDB; any subsequent call here will set <code>signal_blocker</code> but not re-init YDB.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">signal_blocker</span>
         Specifies a Lua callback CFunction (e.g. <code>yottadb.block_M_signals()</code>) which will be
 called with its one parameter set to false on entry to M, and with true on exit from M, so as to unblock YDB signals while M is in use.
 Setting <code>signal_blocker</code> to <code>nil</code> switches off signal blocking.</p>

<p> <em>Note:</em> Changing this to support a generic Lua function as callback would be possible but slow, as it would require
 fetching the function pointer from a C closure, and using <code>lua_call()</code>.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        nothing
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#block_M_signals">block_M_signals</a>
    </ul>


</dd>
    <dt>
    <a name = "kill"></a>
    <strong>kill (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Deletes a database variable tree (node and subnodes) or a node subtree.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="comment">-- include setup from example at yottadb.set()
</span>ydb.get(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
<span class="comment">-- 325737000
</span>ydb.get(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>})
<span class="comment">-- 3929326
</span>ydb.get(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>})
<span class="comment">-- 5308483
</span>ydb.kill(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
ydb.data(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
<span class="comment">-- 0.0</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "lock"></a>
    <strong>lock ([nodes[, timeout]])</strong>
    </dt>
    <dd>
    Releases all locks held and attempts to acquire all requested locks.
 Returns after <code>timeout</code>, if specified.
 If timeout is not supplied or is <code>nil</code>, wait forever; timeout of zero means try only once.
 Raises an error <code>yottadb.YDB_LOCK_TIMEOUT</code> if a lock could not be acquired.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">nodes</span>
         Table array of {varname[, subs]} elements or node objects that specify the lock names to lock.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         Number timeout in seconds to wait for the lock.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>




</dd>
    <dt>
    <a name = "lock_decr"></a>
    <strong>lock_decr (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Decrements a lock of the same name as varname[(subsarray)], releasing it if zero.
 Releasing a lock cannot create an error unless the varname/subsarray names are invalid.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#release">release</a></li>
         <li><a href="yottadb.html#lock_incr">lock_incr</a></li>
    </ul>


</dd>
    <dt>
    <a name = "lock_incr"></a>
    <strong>lock_incr (varname[, subsarray[, ...[, timeout]]])</strong>
    </dt>
    <dd>
    Attempts to acquire or increment a lock named varname[(subsarray)].
 Returns after <code>timeout</code>, if specified.
 Raises a <code>yottadb.YDB_LOCK_TIMEOUT</code> error if lock could not be acquired.</p>

<p> If timeout is not supplied or is <code>nil</code>, wait forever; timeout of zero means try only once.
 <em>Caution:</em> timeout is <em>not</em> optional if <code>...</code> list of subscripts is provided, but it may be <code>nil</code>.
 Otherwise lock_incr cannot tell whether it is a subscript or a timeout.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">timeout</span>
         Number timeout in seconds to wait for the lock.
  Optional only if subscripts is a table.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#grab">grab</a></li>
         <li><a href="yottadb.html#lock_decr">lock_decr</a></li>
    </ul>


</dd>
    <dt>
    <a name = "node_next"></a>
    <strong>node_next (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the full subscript list of the next node after a database variable or node.
 A next node chain started from varname will eventually reach all nodes under that varname in order.</p>

<p> <em>Note:</em> <code>node:gettree()</code> or <code>node:subscripts()</code> may be a better way to iterate a node tree

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        list of subscripts for the node, or <code>nil</code> if there isn't a next node
    </ol>



    <h3>Examples:</h3>
    <ul>
        <li><pre class="example"><span class="comment">-- include setup from example at yottadb.set()
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>), <span class="string">', '</span>))
<span class="comment">-- Belgium
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>}), <span class="string">', '</span>))
<span class="comment">-- Thailand
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'Thailand'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA, 17900802
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA, 18000804</span></pre></li>
        <li><pre class="example"><span class="comment">-- Note: The format used above to print the next node will give an error if there is no next node, i.e., the value returned is nil.
</span><span class="comment">-- This case will have to be handled gracefully. The following code snippet is one way to handle nil as the return value:
</span>
<span class="keyword">local</span> ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
<span class="global">next</span> = ydb.node_next(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>})
<span class="keyword">if</span> <span class="global">next</span> ~= <span class="keyword">nil</span> <span class="keyword">then</span>
  <span class="global">print</span>(<span class="global">table</span>.concat(<span class="global">next</span>, <span class="string">', '</span>))
<span class="keyword">else</span>
  <span class="global">print</span>(<span class="global">next</span>)
<span class="keyword">end</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node_previous"></a>
    <strong>node_previous (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the full subscript list of the previous node after a database variable or node.
 A previous node chain started from varname will eventually reach all nodes under that varname in reverse order.</p>

<p> <em>Note:</em> <code>node:gettree()</code> or <code>node:subscripts()</code> may be a better way to iterate a node tree

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        list of subscripts for the node, or <code>nil</code> if there isn't a previous node
    </ol>



    <h3>Examples:</h3>
    <ul>
        <li><pre class="example"><span class="comment">-- include setup from example at yottadb.set()
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA, 17900802
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>}), <span class="string">', '</span>))
<span class="comment">-- USA
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>}), <span class="string">', '</span>))
<span class="comment">-- Thailand
</span><span class="global">print</span>(<span class="global">table</span>.concat(ydb.node_previous(<span class="string">'^Population'</span>, {<span class="string">'Thailand'</span>}), <span class="string">', '</span>))
<span class="comment">-- Belgium</span></pre></li>
        <li><pre class="example"><span class="comment">-- Note: See the note on handling nil return values in node_next() which applies to node_previous() as well.</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "release"></a>
    <strong>release (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Alias for lock_decr to decrement a lock of the same name as varname[(subsarray)], releasing it if zero.
 Releasing a lock cannot create an error unless the varname/subsarray names are invalid.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String of the database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        0 (always)
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#lock_decr">lock_decr</a></li>
         <li><a href="yottadb.html#grab">grab</a></li>
    </ul>


</dd>
    <dt>
    <a name = "set"></a>
    <strong>set (varname[, subsarray][, ...], value)</strong>
    </dt>
    <dd>
    Sets the value of a database variable or node.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">value</span>
         The value to assign to the node. If this is a number, it is converted to a string. If it is <code>nil</code>, the node's value, if any, is deleted.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <code>value</code>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>}, <span class="number">1367000</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'Thailand'</span>}, <span class="number">8414000</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>}, <span class="number">325737000</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>}, <span class="number">3929326</span>)
ydb.set(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>}, <span class="number">5308483</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "str2zwr"></a>
    <strong>str2zwr (s)</strong>
    </dt>
    <dd>
    Returns the zwrite-formatted version of the given string.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         String to format.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        formatted string
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb=<span class="global">require</span>(<span class="string">'yottadb'</span>)
str=<span class="string">'The quick brown dog\b\b\bfox jumps over the lazy fox\b\b\bdog.'</span>
<span class="global">print</span>(str)
<span class="comment">-- The quick brown fox jumps over the lazy dog.
</span>ydb.str2zwr(str)
<span class="comment">-- "The quick brown dog"_$C(8,8,8)_"fox jumps over the lazy fox"_$C(8,8,8)_"dog."</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "subscript_next"></a>
    <strong>subscript_next (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the next subscript for a database variable or node; or <code>nil</code> if there isn't one.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string subscript name, or <code>nil</code> if there are no more subscripts
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="comment">-- include setup from example at yottadb.set()
</span>ydb.subscript_next(<span class="string">'^Population'</span>, {<span class="string">''</span>})
<span class="comment">-- Belgium
</span>ydb.subscript_next(<span class="string">'^Population'</span>, {<span class="string">'Belgium'</span>})
<span class="comment">-- Thailand
</span>ydb.subscript_next(<span class="string">'^Population'</span>, {<span class="string">'Thailand'</span>})
<span class="comment">-- USA</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "subscript_previous"></a>
    <strong>subscript_previous (varname[, subsarray[, ...]])</strong>
    </dt>
    <dd>
    Returns the previous subscript for a database variable or node; or <code>nil</code> if there isn't one.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string subscript name, or <code>nil</code> if there are no previous subscripts
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="comment">-- include setup from example at yottadb.set()
</span>ydb.subscript_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">''</span>})
<span class="comment">-- 18000804
</span>ydb.subscript_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'18000804'</span>})
<span class="comment">-- 17900802
</span>ydb.subscript_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>, <span class="string">'17900802'</span>})
<span class="comment">-- nil
</span>ydb.subscript_previous(<span class="string">'^Population'</span>, {<span class="string">'USA'</span>})
<span class="comment">-- Thailand</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "subscripts"></a>
    <strong>subscripts (varname[, subsarray[, ...[, reverse]]])</strong>
    </dt>
    <dd>
    Returns an iterator for iterating over database <em>sibling</em> subscripts starting from the node referenced by <a href="yottadb.html#node:varname">varname</a> and <code>subarray</code>. </p>

<p> <em>Note:</em> this starts from the given location and gives the next <em>sibling</em> subscript in the M collation sequence.
 It operates differently than <code>node:subscipts()</code> which yields all subscripts that are <em>children</em> of the given node,
 and which you may consider to be preferable.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         of database node (this can also be replaced by cachearray)
        </li>
        <li><span class="parameter">subsarray</span>
         Table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         List of subscripts or table subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">reverse</span>
         Flag that indicates whether to iterate backwards.  Not optional when '...' is provided
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        iterator
    </ol>




</dd>
    <dt>
    <a name = "ydb_eintr_handler"></a>
    <strong>ydb_eintr_handler ()</strong>
    </dt>
    <dd>
    Lua function to call <code>ydb_eintr_handler()</code>.
 Code intended to handle EINTR errors, instead of blocking signals, should call <code>ydb_eintr_handler()</code> when it gets an EINTR return code,
 before re-issuing the interrupted system call.

    </ul>
    </ul>


    <h3>Returns:</h3>
    <ol>

        YDB_OK on success, and greater than zero on error (with message in ZSTATUS)
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#block_M_signals">block_M_signals</a>
    </ul>


</dd>
    <dt>
    <a name = "zwr2str"></a>
    <strong>zwr2str (s)</strong>
    </dt>
    <dd>
    Returns the string described by the given zwrite-formatted string.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         String in zwrite format.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb=<span class="global">require</span>(<span class="string">'yottadb'</span>)
str1=<span class="string">'The quick brown dog\b\b\bfox jumps over the lazy fox\b\b\bdog.'</span>
zwr_str=ydb.str2zwr(str1)
<span class="global">print</span>(zwr_str)
<span class="comment">-- "The quick brown dog"_$C(8,8,8)_"fox jumps over the lazy fox"_$C(8,8,8)_"dog."
</span>str2=ydb.zwr2str(zwr_str)
<span class="global">print</span>(str2)
<span class="comment">-- The quick brown fox jumps over the lazy dog.
</span>str1==str2
<span class="comment">-- true</span></pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Transactions"></a>Transactions </h2>

    <dl class="function">
    <dt>
    <a name = "tp"></a>
    <strong>tp ([id][, varnames], f[, ...])</strong>
    </dt>
    <dd>
    Initiates a transaction (low level function).
 Restarts are subject to <code>$ZMAXTPTIME</code> after which they cause error <code>%YDB-E-TPTIMEOUT</code>

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
         optional string transaction id. For special ids <code>BA</code> or <code>BATCH</code>, see <a href="https://docs.yottadb.com/ProgrammersGuide/langfeat.html#transaction-processing">Transaction Processing</a>.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">varnames</span>
         optional table of local M variable names to restore on transaction restart
 (or <code>{&apos;*&apos;}</code> for all locals)
 Restoration applies to rollback.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">f</span>

<p> Function to call. The transaction's affected globals are:</p>

<ul>
    <li>Committed if the function returns nothing or <code>yottadb.YDB_OK</code>.</li>
    <li>Restarted if the function returns <code>yottadb.YDB_TP_RESTART</code> (<code>f</code> will be called again).</li>
    <li>Not committed if the function returns <code>yottadb.YDB_TP_ROLLBACK</code> or errors out.</li>
</ul>

        </li>
        <li><span class="parameter">...</span>
         arguments to pass to <code>f</code>
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#transaction">transaction</a>
    </ul>

    <h3>Examples:</h3>
    <ul>
        <li><pre class="example"><span class="keyword">local</span> ydb = <span class="global">require</span>(<span class="string">'yottadb'</span>)

<span class="keyword">function</span> transfer_to_savings(t)
   <span class="keyword">local</span> ok, e = <span class="global">pcall</span>(ydb.incr, <span class="string">'^checking'</span>, -t)
   <span class="keyword">if</span> (ydb.get_error_code(e) == ydb.YDB_TP_RESTART) <span class="keyword">then</span>
      <span class="keyword">return</span> ydb.YDB_TP_RESTART
   <span class="keyword">end</span>
   <span class="keyword">if</span> (<span class="keyword">not</span> ok <span class="keyword">or</span> <span class="global">tonumber</span>(e)&lt;<span class="number">0</span>) <span class="keyword">then</span>
      <span class="keyword">return</span> ydb.YDB_TP_ROLLBACK
   <span class="keyword">end</span>
   <span class="keyword">local</span> ok, e = <span class="global">pcall</span>(ydb.incr, <span class="string">'^savings'</span>, t)
   <span class="keyword">if</span> (ydb.get_error_code(e) == ydb.YDB_TP_RESTART) <span class="keyword">then</span>
      <span class="keyword">return</span> ydb.YDB_TP_RESTART
   <span class="keyword">end</span>
   <span class="keyword">if</span> (<span class="keyword">not</span> ok) <span class="keyword">then</span>
      <span class="keyword">return</span> ydb.YDB_TP_ROLLBACK
   <span class="keyword">end</span>
   <span class="keyword">return</span> ydb.YDB_OK
<span class="keyword">end</span>

ydb.set(<span class="string">'^checking'</span>, <span class="number">200</span>)
ydb.set(<span class="string">'^savings'</span>, <span class="number">85000</span>)

<span class="global">print</span>(<span class="string">"Amount currently in checking account: $"</span> .. ydb.get(<span class="string">'^checking'</span>))
<span class="global">print</span>(<span class="string">"Amount currently in savings account: $"</span> .. ydb.get(<span class="string">'^savings'</span>))

<span class="global">print</span>(<span class="string">"Transferring $10 from checking to savings"</span>)
<span class="keyword">local</span> ok, e = <span class="global">pcall</span>(ydb.tp, <span class="string">''</span>, {<span class="string">'*'</span>}, transfer_to_savings, <span class="number">10</span>)
<span class="keyword">if</span> (<span class="keyword">not</span> e) <span class="keyword">then</span>
   <span class="global">print</span>(<span class="string">"Transfer successful"</span>)
<span class="keyword">elseif</span> (ydb.get_error_code(e) == ydb.YDB_TP_ROLLBACK) <span class="keyword">then</span>
   <span class="global">print</span>(<span class="string">"Transfer not possible. Insufficient funds"</span>)
<span class="keyword">end</span>

<span class="global">print</span>(<span class="string">"Amount in checking account: $"</span> .. ydb.get(<span class="string">'^checking'</span>))
<span class="global">print</span>(<span class="string">"Amount in savings account: $"</span> .. ydb.get(<span class="string">'^savings'</span>))

<span class="global">print</span>(<span class="string">"Transferring $1000 from checking to savings"</span>)
<span class="keyword">local</span> ok, e = <span class="global">pcall</span>(ydb.tp, <span class="string">''</span>, {<span class="string">'*'</span>}, transfer_to_savings, <span class="number">1000</span>)
<span class="keyword">if</span> (<span class="keyword">not</span> e) <span class="keyword">then</span>
   <span class="global">print</span>(<span class="string">"Transfer successful"</span>)
<span class="keyword">elseif</span> (ydb.get_error_code(e) == ydb.YDB_TP_ROLLBACK) <span class="keyword">then</span>
   <span class="global">print</span>(<span class="string">"Transfer not possible. Insufficient funds"</span>)
<span class="keyword">end</span>

<span class="global">print</span>(<span class="string">"Amount in checking account: $"</span> .. ydb.get(<span class="string">'^checking'</span>))
<span class="global">print</span>(<span class="string">"Amount in savings account: $"</span> .. ydb.get(<span class="string">'^savings'</span>))</pre></li>
        <li><pre class="example">Output:
  Amount currently <span class="keyword">in</span> checking account: $<span class="number">200</span>
  Amount currently <span class="keyword">in</span> savings account: $<span class="number">85000</span>
  Transferring $<span class="number">10</span> from checking to savings
  Transfer successful
  Amount <span class="keyword">in</span> checking account: $<span class="number">190</span>
  Amount <span class="keyword">in</span> savings account: $<span class="number">85010</span>
  Transferring $<span class="number">1000</span> from checking to savings
  Transfer <span class="keyword">not</span> possible. Insufficient funds
  Amount <span class="keyword">in</span> checking account: $<span class="number">190</span>
  Amount <span class="keyword">in</span> savings account: $<span class="number">85010</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "transaction"></a>
    <strong>transaction ([id][, varnames], f)</strong>
    </dt>
    <dd>
    Returns a high-level transaction-safe version of the given function.
 It will be called within a YottaDB transaction and the database globals restored on error or <code>yottadb.trollback()</code>

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
         optional string transaction id. For special ids <code>BA</code> or <code>BATCH</code>, see <a href="https://docs.yottadb.com/ProgrammersGuide/langfeat.html#transaction-processing">Transaction Processing</a>.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">varnames</span>
         optional table of local M variable names to restore on transaction <code>trestart()</code>
 (or <code>{&apos;*&apos;}</code> for all locals). Restoration applies to rollback.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">f</span>

<p> Function to call. The transaction's affected globals are:</p>

<ul>
    <li>Committed if the function returns nothing or <code>yottadb.YDB_OK</code>.</li>
    <li>Restarted if the function returns <code>yottadb.YDB_TP_RESTART</code> (<code>f</code> will be called again).
    Restarts are subject to <code>$ZMAXTPTIME</code> after which they cause error <code>%YDB-E-TPTIMEOUT</code></li>
    <li>Not committed if the function returns <code>yottadb.YDB_TP_ROLLBACK</code> or errors out.</li>
</ul>

        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        transaction-safe function.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#tp">tp</a>
    </ul>

    <h3>Example:</h3>
    <ul>
        <pre class="example">Znode = ydb.node(<span class="string">'^Ztest'</span>)
transact = ydb.transaction(<span class="keyword">function</span>(end_func)
  <span class="global">print</span>(<span class="string">"^Ztest starts as"</span>, Znode:get())
  Znode:set(<span class="string">'value'</span>)
  end_func()
  <span class="keyword">end</span>)

transact(ydb.trollback)  <span class="comment">-- perform a rollback after setting Znode
</span><span class="comment">-- ^Ztest starts as	nil
</span><span class="comment">-- YDB Error: 2147483645: YDB_TP_ROLLBACK
</span><span class="comment">-- stack traceback:
</span><span class="comment">--   [C]: in function '_yottadb.tp' ...
</span>Znode:get()  <span class="comment">-- see that the data didn't get set
</span><span class="comment">-- nil
</span>
tries = <span class="number">2</span>
<span class="keyword">function</span> trier()  tries=tries-<span class="number">1</span>  <span class="keyword">if</span> tries&gt;<span class="number">0</span> <span class="keyword">then</span> ydb.trestart() <span class="keyword">end</span>  <span class="keyword">end</span>
transact(trier)  <span class="comment">-- restart with initial dbase state and try again
</span><span class="comment">-- ^Ztest starts as	nil
</span><span class="comment">-- ^Ztest starts as	nil
</span>Znode:get()  <span class="comment">-- check that the data got set after restart
</span><span class="comment">-- value
</span>
Znode:set(<span class="keyword">nil</span>)
transact(<span class="keyword">function</span>() <span class="keyword">end</span>)  <span class="comment">-- end the transaction normally without restart
</span><span class="comment">-- ^Ztest starts as	nil
</span>Znode:get()  <span class="comment">-- check that the data got set
</span><span class="comment">-- value</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "trestart"></a>
    <strong>trestart ()</strong>
    </dt>
    <dd>
    Make the currently running transaction function restart immediately.

    </ul>
    </ul>






</dd>
    <dt>
    <a name = "trollback"></a>
    <strong>trollback ()</strong>
    </dt>
    <dd>
    Make the currently running transaction function rollback immediately with a YDB<em>TP</em>ROLLBACK error.

    </ul>
    </ul>






</dd>
</dl>
    <h2 class="section-header "><a name="High_level_functions"></a>High level functions </h2>

    <dl class="function">
    <dt>
    <a name = "dump"></a>
    <strong>dump (node[, ...[, maxlines=30]])</strong>
    </dt>
    <dd>
    Dump the specified node tree.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">node</span>
         Either a node object with <code>...</code> subscripts or glvn varname with <code>...</code> subsarray
        </li>
        <li><span class="parameter">...</span>
         Either a table or a list of subscripts to add to node
         (<em>optional</em>)
        </li>
        <li><span class="parameter">maxlines</span>
         Maximum number of lines to output before stopping dump
         (<em>default</em> 30)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        dump as a string
    </ol>



    <h3>Examples:</h3>
    <ul>
        <li><pre class="example">ydb.dump(node, [...[, maxlines]])</pre></li>
        <li><pre class="example">ydb.dump(<span class="string">'^MYVAR'</span>, <span class="string">'people'</span>)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "require"></a>
    <strong>require (Mprototypes)</strong>
    </dt>
    <dd>
    Import M routines as Lua functions specified in ydb 'call-in' file.  <br>
 See example call-in file <a href="https://github.com/anet-be/lua-yottadb/blob/master/examples/arithmetic.ci">arithmetic.ci</a>
 and matching M file <a href="https://github.com/anet-be/lua-yottadb/blob/master/examples/arithmetic.m">arithmetic.m</a>.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">Mprototypes</span>
         A list of lines in the format of ydb 'call-in' files required by <code>ydb_ci()</code>.
 If the string contains <code>:</code> it is considered to be the call-in specification itself;
 otherwise it is treated as the filename of a call-in file to be opened and read.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        A table of functions analogous to a Lua module.
 Each function in the table will call an M routine specified in <code>Mprototypes</code>.
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">$ export ydb_routines=examples   # put arithmetic.m (below) into ydb path
$ lua -lyottadb
arithmetic = yottadb.<span class="global">require</span>(<span class="string">'examples/arithmetic.ci'</span>)
arithmetic.add_verbose(<span class="string">"Sum is:"</span>, <span class="number">2</span>, <span class="number">3</span>)
<span class="comment">-- Sum is: 5
</span><span class="comment">-- Sum is: 5
</span>arithmetic.sub(<span class="number">5</span>,<span class="number">7</span>)
<span class="comment">-- -2</span></pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Node_class_operations"></a>Node class operations </h2>

    <dl class="function">
    <dt>
    <a name = "inherit"></a>
    <strong>inherit (node_func[, metatable])</strong>
    </dt>
    <dd>
    Create a new node class that inherits from the yottadb.node superclass.
 The returned function will generate nodes of a new class (a new metatable). You may add or
 override class methods by adding them to <code>new_metatable</code> either before or after calling inherit.
 Any class method the user does not define in <code>new_metatable</code> will default to the class method of the superclass.
 If desired, the new class may be further subclassed, also using <a href="yottadb.html#inherit">inherit</a>. Refer to the example below, and further
 explanation in the <a href="https://github.com/anet-be/lua-yottadb#class-inheritance">README</a>.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">node_func</span>
         <a href="yottadb.html#node">yottadb.node</a> or a descendent that inherits from it using <a href="yottadb.html#inherit">inherit</a>
        </li>
        <li><span class="parameter">metatable</span>
         to use for the new node class. Defaults to <code>{}</code>.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        function that generates node of the new type</li>
        <li>
        subclass metatable (modified)</li>
        <li>
        superclass metatable used by the original node_func</li>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="comment">-- To average all data stored in a particular database node:
</span>averaged_node, class, superclass = ydb.inherit(ydb.node)
<span class="keyword">function</span> class:set(value)  sum=sum+value  writes=writes+<span class="number">1</span>  <span class="keyword">return</span> superclass.set(self, value)  <span class="keyword">end</span>

<span class="comment">-- Now use the new class
</span>sum, writes = <span class="number">0</span>, <span class="number">0</span>
shoesize = averaged_node(<span class="string">'shoesize'</span>)
shoesize:set(<span class="number">5</span>)
shoesize:set(<span class="number">10</span>)
shoesize.__ = <span class="number">15</span>  <span class="comment">-- overriding set() also changes the behaviour of: .__ =
</span><span class="global">print</span>(<span class="string">'Average'</span>, sum/writes)
<span class="comment">-- Average 10.0</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "isnode"></a>
    <strong>isnode (object)</strong>
    </dt>
    <dd>
    Tests whether object is a node object or inherits from a node object.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">object</span>
         to test
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        boolean true or false
    </ol>




</dd>
    <dt>
    <a name = "node"></a>
    <strong>node (varname[, subsarray][, ...], node)</strong>
    </dt>
    <dd>

<p>Creates an object that represents a YottaDB node.
 This node has all of the class methods defined below.
 Calling the returned node with one or more string parameters returns a new node further subscripted by those strings.
 Calling this on an existing node <code>yottadb.node(node)</code> creates an (immutable) copy of node.</p>

<p> <em>Notes:</em></p>

<ul>
    <li>Several standard Lua operators work on nodes. These are: <code>+</code> <code>-</code> <code>=</code> <code>pairs()</code> <code>tostring()</code></li>
    <li>Although the syntax <code>node:method()</code> is pretty, be aware that it is slow. If you need speed, prefix the node method
    with two underscores, <code>node:__method()</code>, which is equivalent, but 15x faster.
    The former is slow because in Lua, <code>node:method(...)</code> is syntactic sugar which expands to <code>node.method(node, ...)</code>,
    causing lua-yottadb to create an intermediate node object <code>node.method</code>. It is only when this new object gets called
    with <code>(node, ...)</code>, and the first parameter is of type <a href="yottadb.html#node">node</a>, that the <code>__call</code> metamethod detects it was supposed to
    be a method access and invokes <code>node.__method()</code>, discarding the intermediate subnode object it created.</li>
    <li>Because the <code>__</code> prefix accesses <em>method</em> names (as above), it cannot access database subnode names starting with <code>__</code>.
    Instead, use mynode('__nodename') to access a database node named <code>__nodename</code>.</li>
    <li>This <code>__</code> prefix handling also means that object method names that start with two underscores, like <code>__tostring</code>,
    are only accessible with an <em>additional</em> <code>__</code> prefix; for example, <code>node:____tostring()</code>.</li>
</ul>


    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String variable name.
        </li>
        <li><span class="parameter">subsarray</span>
         table of subscripts
         (<em>optional</em>)
        </li>
        <li><span class="parameter">...</span>
         list of subscripts to append after any elements in optional subsarray table
         (<em>optional</em>)
        </li>
        <li><span class="parameter">node</span>
         <code>|key:</code> is an existing node or key to copy into a new object (you can turn a <a href="yottadb.html#key">key</a> type into a <a href="yottadb.html#node">node</a> type this way)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        node object with metatable <a href="yottadb.html#node">yottadb.node</a>
    </ol>



    <h3>Example:</h3>
    <ul>
        <pre class="example">yottadb.node(<span class="string">'varname'</span>[, {subsarray}][, ...])
yottadb.node(node|key[, {}][, ...])
yottadb.node(<span class="string">'varname'</span>)(<span class="string">'sub1'</span>, <span class="string">'sub2'</span>)
yottadb.node(<span class="string">'varname'</span>, <span class="string">'sub1'</span>, <span class="string">'sub2'</span>)
yottadb.node(<span class="string">'varname'</span>, {<span class="string">'sub1'</span>, <span class="string">'sub2'</span>})
yottadb.node(<span class="string">'varname'</span>).sub1.sub2
yottadb.node(<span class="string">'varname'</span>)[<span class="string">'sub1'</span>][<span class="string">'sub2'</span>]</pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Node_class"></a>Node class </h2>

    <dl class="function">
    <dt>
    <a name = "node:__ipairs"></a>
    <strong>node:__ipairs ()</strong>
    </dt>
    <dd>
    Not implemented: use <code>pairs(node)</code> or <code>node:__pairs()</code> instead.
 See alternative usage below.
 This is not implemented because
 Lua >=5.3 implements ipairs via <code>__index()</code>.
 This would mean that <code>__index()</code> would have to treat integer subscript lookup specially, so:</p>

<ul>
    <li>Although <code>node[&apos;abc&apos;]</code>  => produces a new node so that <code>node.abc.def.ghi</code> works.</li>
    <li><code>node[1]</code>  => would have to produce value <code>node(1).__</code> so ipairs() works. <br>
    Since ipairs() will be little used anyway, the consequent inconsistency discourages implementation.</li>
</ul>

<p> Alternatives using <code>pairs()</code> are as follows:

    </ul>
    </ul>





    <h3>Examples:</h3>
    <ul>
        <li><pre class="example"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(node) <span class="keyword">do</span>   <span class="keyword">if</span> <span class="keyword">not</span> <span class="global">tonumber</span>(k) <span class="keyword">break</span> <span class="keyword">end</span>   &lt;do_your_stuff with k,v&gt;   <span class="keyword">end</span>
 <span class="comment">-- this works since M sorts numbers first by default. The order may be changed by specifying a non-default collation on the database</span></pre></li>
        <li><pre class="example"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">1</span>/<span class="number">0</span> <span class="keyword">do</span>   v=node[i].__  <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">break</span> <span class="keyword">then</span>   &lt;do_your_stuff with k,v&gt;   <span class="keyword">end</span>
 <span class="comment">-- alternative that ensures integer keys</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node:__pairs"></a>
    <strong>node:__pairs ([reverse])</strong>
    </dt>
    <dd>

<p>Implement <code>pairs()</code> by iterating over the children of a given node.
 At each child, yielding the triplet: subnode, subnode value (or <code>nil</code>), and subscript.
 You can use either <code>pairs(node)</code> or <code>node:pairs()</code>.
 If you need to iterate in reverse (or in Lua 5.1), use node:pairs(reverse) instead of pairs(node).</p>

<p> <em>Caution:</em> for the sake of speed, the iterator supplies a <em>mutable</em> node. This means it can
 re-use the same node for each iteration by changing its last subscript, making it faster.
 But if your loop needs to retain a reference to the node after loop iteration, it should create
 an immutable copy of that node using <code>ydb.node(node)</code>.
 Mutability can be tested for using <code>node:ismutable()</code></p>

<p> <em>Notes:</em></p>

<ul>
    <li><code>pairs()</code> order is guaranteed to equal the M collation sequence order
    (even though <code>pairs()</code> order is not normally guaranteed for Lua tables).
    This means that <code>pairs()</code> is a reasonable substitute for ipairs which is not implemented.</li>
    <li>This is very slightly slower than <code>node:subscripts()</code> which only iterates subscript names without
    fetching the node value.</li>
</ul>


    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         Boolean flag iterates in reverse if true
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        3 values: <code>subnode_object</code>, <code>subnode_value_or_nil</code>, <code>subscript</code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:subscripts">node:subscripts</a>
    </ul>

    <h3>Example:</h3>
    <ul>
        <pre class="example"><span class="keyword">for</span> subnode,value[,subscript] <span class="keyword">in</span> <span class="global">pairs</span>(node) <span class="keyword">do</span>  subnode:incr(value)  <span class="keyword">end</span>
 <span class="comment">-- to double the values of all subnodes of node</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "node:__repr"></a>
    <strong>node:__repr ()</strong>
    </dt>
    <dd>
    Return raw representation of node's unique memory address.

    </ul>
    </ul>


    <h3>Returns:</h3>
    <ol>

        string in hexadecimal format, starting with <code>0x</code>.
    </ol>




</dd>
    <dt>
    <a name = "node:delete_tree"></a>
    <strong>node:delete_tree ()  [deprecated v3.0]:</strong>
    </dt>
    <dd>
    Deprecated and replaced by kill.

    </ul>
    </ul>




    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#kill">kill</a>
    </ul>


</dd>
    <dt>
    <a name = "node:dump"></a>
    <strong>node:dump ([maxlines=30])</strong>
    </dt>
    <dd>
    Dump the specified node tree.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">maxlines</span>
         Maximum number of lines to output before stopping dump
         (<em>default</em> 30)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        dump as a string
    </ol>




</dd>
    <dt>
    <a name = "node:get"></a>
    <strong>node:get ([default])</strong>
    </dt>
    <dd>
    Get <a href="yottadb.html#node">node</a>'s value.
 Equivalent to <code>node.__</code>, but 2.5x slower.
 If node is subclassed, then <code>node.__</code> invokes the subclass's <code>node:__get()</code> if it exists.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">default</span>
         specify the value to return if the node has no data; if not supplied, <code>nil</code> is the default
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        value of the node
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#get">get</a>
    </ul>


</dd>
    <dt>
    <a name = "node:gettree"></a>
    <strong>node:gettree ([maxdepth[, filter[, _value[, _depth]]]])</strong>
    </dt>
    <dd>

<p>Fetch database node and subtree and return a Lua table of it. </p>

<p> <em>Notes:</em></p>

<ul>
    <li>special field name <code>__</code> in the returned table indicates the value of the node itself.</li>
    <li>Lua tables do not preserve the order YDB subtrees.</li>
</ul>


    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">maxdepth</span>
         Subscript depth to fetch. A value of nil fetches subscripts of arbitrary depth, i.e. all levels in the tree. A value of 1 fetches the first layer of subscript values only.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">filter</span>

<p> Either <code>nil</code> or a function matching the prototype <code>function(node, node_top_subscript_name, value, recurse, depth)</code></p>

<ul>
    <li>If filter is <code>nil</code>, all values are fetched unfiltered.</li>
    <li>If filter is a function it is invoked on every subscript
    to allow it to cast/alter every value and recurse flag;
    note that at node root (depth=0), subscript passed to filter is the empty string "".</li>
    <li>Filter may optionally return two items: <code>value</code> and <code>recurse</code>, which must either be the input parameters <code>value</code> and <code>recurse</code> or may be altered:
    <ul>
        <li>If filter returns <code>value</code> then <code>gettree()</code> will store it in the table for that database subscript/value; or store nothing if <code>value=nil</code>.</li>
        <li>If filter returns <code>recurse=false</code>, it will prevent recursion deeper into that particular subscript. If it returns <code>nil</code>, it will use the original value of <code>recurse</code>.</li>
    </ul></li>
</ul>

         (<em>optional</em>)
        </li>
        <li><span class="parameter">_value</span>
         For internal use only (to avoid duplicate value fetches, for speed).
         (<em>optional</em>)
        </li>
        <li><span class="parameter">_depth</span>
         For internal use only (to record depth of recursion) and must start unspecified (nil).
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Lua table containing data
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:settree">settree</a>
    </ul>

    <h3>Example:</h3>
    <ul>
        <pre class="example">n = ydb.node(<span class="string">'^oaks'</span>)
n:settree({__=<span class="string">'treedata'</span>, {shadow=<span class="number">10</span>,angle=<span class="number">30</span>}, {shadow=<span class="number">13</span>,angle=<span class="number">30</span>}})
n:gettree(<span class="keyword">nil</span>, <span class="global">print</span>)
<span class="comment">-- ^oaks		treedata	true	0
</span><span class="comment">-- ^oaks(1)	1	nil	true	1
</span><span class="comment">-- ^oaks(1,"angle")	angle	30	false	2
</span><span class="comment">-- ^oaks(1,"shadow")	shadow	10	false	2
</span><span class="comment">-- ^oaks(2)	2	nil	true	1
</span><span class="comment">-- ^oaks(2,"angle")	angle	30	false	2
</span><span class="comment">-- ^oaks(2,"shadow")	shadow	13	false	2
</span>
<span class="comment">-- now fetch the tree into a Lua table
</span>tbl = n:gettree()</pre>
    </ul>

</dd>
    <dt>
    <a name = "node:grab"></a>
    <strong>node:grab ([timeout])</strong>
    </dt>
    <dd>
    Alias for node:lock_incr to acquire or increment a lock matching this node.
 Returns after <code>timeout</code>, if specified.
 If timeout is not supplied or is <code>nil</code>, wait forever; timeout of zero means try only once.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         Number timeout in seconds to wait for the lock.
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#grab">grab</a></li>
         <li><a href="yottadb.html#node:lock_incr">node:lock_incr</a></li>
         <li><a href="yottadb.html#node:release">node:release</a></li>
    </ul>


</dd>
    <dt>
    <a name = "node:incr"></a>
    <strong>node:incr ([increment=1])</strong>
    </dt>
    <dd>
    Increment <a href="yottadb.html#node">node</a>'s value.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">increment</span>
         Amount to increment by (negative to decrement)
         (<em>default</em> 1)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the new value
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#incr">incr</a>
    </ul>


</dd>
    <dt>
    <a name = "node:kill"></a>
    <strong>node:kill ()</strong>
    </dt>
    <dd>
    Delete database tree (node and subnodes) pointed to by node object.

    </ul>
    </ul>




    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:kill">node:kill</a>
    </ul>


</dd>
    <dt>
    <a name = "node:lock"></a>
    <strong>node:lock ([timeout])</strong>
    </dt>
    <dd>
    Releases all locks held and attempts to acquire a lock matching only this node.
 Returns after <code>timeout</code>, if specified.
 If timeout is not supplied or is <code>nil</code>, wait forever; timeout of zero means try only once.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         Number timeout in seconds to wait for the lock.
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#lock">lock</a>
    </ul>


</dd>
    <dt>
    <a name = "node:lock_decr"></a>
    <strong>node:lock_decr ()</strong>
    </dt>
    <dd>
    Decrements a lock matching this node, releasing it if zero.

    </ul>
    </ul>




    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#lock_decr">lock_decr</a></li>
         <li><a href="yottadb.html#node:release">node:release</a></li>
         <li><a href="yottadb.html#node:lock_incr">node:lock_incr</a></li>
    </ul>


</dd>
    <dt>
    <a name = "node:lock_incr"></a>
    <strong>node:lock_incr ([timeout])</strong>
    </dt>
    <dd>
    Attempts to acquire or increment a lock matching this node.
 Returns after <code>timeout</code>, if specified.
 If timeout is not supplied or is <code>nil</code>, wait forever; timeout of zero means try only once.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         Number timeout in seconds to wait for the lock.
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#lock_incr">lock_incr</a></li>
         <li><a href="yottadb.html#node:grab">node:grab</a></li>
         <li><a href="yottadb.html#node:lock_decr">node:lock_decr</a></li>
    </ul>


</dd>
    <dt>
    <a name = "node:release"></a>
    <strong>node:release ()</strong>
    </dt>
    <dd>
    Alias for node:lock_decr to decrement a lock matching this node, releasing it if zero.

    </ul>
    </ul>




    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#release">release</a></li>
         <li><a href="yottadb.html#node:lock_decr">node:lock_decr</a></li>
         <li><a href="yottadb.html#node:grab">node:grab</a></li>
    </ul>


</dd>
    <dt>
    <a name = "node:set"></a>
    <strong>node:set (value)</strong>
    </dt>
    <dd>
    Set <a href="yottadb.html#node">node</a>'s value.
 Equivalent to <code>node.__ = x</code>, but 4x slower.
 If node is subclassed, then <code>node.__ = x</code> invokes the subclass's <code>node:__set(x)</code> if it exists.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         New value or <code>nil</code> to delete node
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        value
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#set">set</a>
    </ul>


</dd>
    <dt>
    <a name = "node:settree"></a>
    <strong>node:settree (tbl[, filter[, _seen]])</strong>
    </dt>
    <dd>

<p>Populate database from a table.
 In its simplest form:</p>
<pre><code>n = ydb.node('var')
n:settree({__='berwyn', weight=78, ['!@#$']='junk', appearance={__='handsome', eyes='blue', hair='blond'}, age=ydb.DELETE})
</code></pre>


    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">tbl</span>

<p> The table to store into the database:</p>

<ul>
    <li>Special field name <code>tbl.__</code> sets the value of the node itself, as opposed to a subnode.</li>
    <li>Set any table value to <code>yottadb.DELETE</code> to have <code>settree()</code> delete the value of the associated database node. You cannot delete the whole subtree.</li>
</ul>

        </li>
        <li><span class="parameter">filter</span>

<p> Function of the form <code>function(node, key, value)</code> or <code>nil</code></p>

<ul>
    <li>If filter is <code>nil</code>, all values are set unfiltered.</li>
    <li>If filter is a function(node, key, value) it is invoked on every node
    to allow it to cast/alter every key name and value.</li>
    <li>Filter must return the same or altered: key, value.</li>
    <li>Type errors can be handled (or ignored) using this function, too.</li>
    <li>If filter returns <code>yottadb.DELETE</code> as value, the key is deleted.</li>
    <li>If filter returns <code>nil</code> as key or value, <code>settree()</code> will simply not update the current database value.</li>
</ul>

         (<em>optional</em>)
        </li>
        <li><span class="parameter">_seen</span>
         For internal use only (to prevent accidental duplicate sets: bad because order setting is not guaranteed).
         (<em>optional</em>)
        </li>
    </ul>




    <h3>Examples:</h3>
    <ul>
        <li><pre class="example">n = ydb.node(<span class="string">'^oaks'</span>)
n:settree({__=<span class="string">'treedata'</span>, {shadow=<span class="number">10</span>,angle=<span class="number">30</span>}, {shadow=<span class="number">13</span>,angle=<span class="number">30</span>}})
n:dump()</pre></li>
        <li><pre class="example"><span class="comment">-- outputs:
</span>^oaks=<span class="string">"treedata"</span>
^oaks(<span class="string">"1"</span>,<span class="string">"angle"</span>)=<span class="string">"30"</span>
^oaks(<span class="string">"1"</span>,<span class="string">"shadow"</span>)=<span class="string">"10"</span>
^oaks(<span class="string">"2"</span>,<span class="string">"angle"</span>)=<span class="string">"30"</span>
^oaks(<span class="string">"2"</span>,<span class="string">"shadow"</span>)=<span class="string">"13"</span></pre></li>
    </ul>

</dd>
    <dt>
    <a name = "node:subscripts"></a>
    <strong>node:subscripts ([reverse])</strong>
    </dt>
    <dd>
    Return iterator over the <em>child</em> subscript names of a node (in M terms, collate from "" to "").
 Unlike <code>yottadb.subscripts()</code>, <code>node:subscripts()</code> returns all <em>child</em> subscripts, not subsequent <em>sibling</em> subscripts in the same level. <br>
 Very slightly faster than node:__pairs() because it iterates subscript names without fetching the node value. <br>
 Note that <code>subscripts()</code> order is guaranteed to equal the M collation sequence.

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         set to true to iterate in reverse order
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        iterator over <em>child</em> subscript names of a node, which returns a sequence of subscript name strings
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node:__pairs">node:__pairs</a>
    </ul>

    <h3>Example:</h3>
    <ul>
        <pre class="example">ydb = <span class="global">require</span> <span class="string">'yottadb'</span>
node = ydb.node(<span class="string">'^myvar'</span>, <span class="string">'subs1'</span>)
<span class="keyword">for</span> subscript <span class="keyword">in</span> node:subscripts() <span class="keyword">do</span>  <span class="global">print</span> subscript  <span class="keyword">end</span></pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Node_class_properties"></a>Node class properties </h2>

    <dl class="function">
    <dt>
    <a name = "node:data"></a>
    <strong>node:data ()</strong>
    </dt>
    <dd>
    Fetch the 'data' bitfield of the node that describes whether the node has a data value or subtrees.

    </ul>
    </ul>


    <h3>Returns:</h3>
    <ol>

           <code>yottadb.YDB_DATA_UNDEF</code> (no value or subtree) or <br>
   <code>yottadb.YDB_DATA_VALUE_NODESC</code> (value, no subtree) or <br>
   <code>yottadb.YDB_DATA_NOVALUE_DESC</code> (no value, subtree) or <br>
   <code>yottadb.YDB_DATA_VALUE_DESC</code> (value and subtree)
    </ol>




</dd>
    <dt>
    <a name = "node:depth"></a>
    <strong>node:depth ()</strong>
    </dt>
    <dd>
    Fetch the depth of the node: how many subscripts it has.

    </ul>
    </ul>






</dd>
    <dt>
    <a name = "node:has_tree"></a>
    <strong>node:has_tree ()</strong>
    </dt>
    <dd>
    Return true if the node has a tree; otherwise false.

    </ul>
    </ul>






</dd>
    <dt>
    <a name = "node:has_value"></a>
    <strong>node:has_value ()</strong>
    </dt>
    <dd>
    Return true if the node has a value; otherwise false.

    </ul>
    </ul>






</dd>
    <dt>
    <a name = "node:ismutable"></a>
    <strong>node:ismutable ()</strong>
    </dt>
    <dd>
    Return true if the node is mutable; otherwise false.

    </ul>
    </ul>






</dd>
    <dt>
    <a name = "node:name"></a>
    <strong>node:name ()</strong>
    </dt>
    <dd>
    Fetch the name of the node: the rightmost subscript.

    </ul>
    </ul>






</dd>
    <dt>
    <a name = "node:subsarray"></a>
    <strong>node:subsarray ()</strong>
    </dt>
    <dd>
    Return <a href="yottadb.html#node">node</a>'s subsarray of subscript strings as a table.

    </ul>
    </ul>






</dd>
    <dt>
    <a name = "node:varname"></a>
    <strong>node:varname ()</strong>
    </dt>
    <dd>
    Fetch the varname of the node: the leftmost subscript.

    </ul>
    </ul>






</dd>
</dl>
    <h2 class="section-header "><a name="Key_class"></a>Key class </h2>

    <dl class="function">
    <dt>
    <a name = "_property_"></a>
    <strong>_property_  [deprecated v1.0]:</strong>
    </dt>
    <dd>
    Properties of key object that are accessed with a dot.
 These properties, listed below, are unlike object methods, which are accessed with a colon.
 This kind of property access is for backward compatibility.</p>

<p> For example, access data property with: <code>key.data</code>

    </ul>
    </ul>

    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">name</span>
         equivalent to <code>node:name()</code>
        </li>
        <li><span class="parameter">data</span>
         equivalent to <code>node:data()</code>
        </li>
        <li><span class="parameter">has_value</span>
         equivalent to <code>node:has_value()</code>
        </li>
        <li><span class="parameter">has_tree</span>
         equivalent to <code>node:has_tree()</code>
        </li>
        <li><span class="parameter">value</span>
         equivalent to <code>node.__</code>
        </li>
        <li><span class="parameter">__varname</span>
         database variable name string -- for compatibility with a previous version
        </li>
        <li><span class="parameter">__subsarray</span>
         table array of database subscript name strings -- for compatibility with a previous version
        </li>
    </ul>





</dd>
    <dt>
    <a name = "key"></a>
    <strong>key (varname[, subsarray])  [deprecated v1.0]:</strong>
    </dt>
    <dd>

<p>Creates an object that represents a YDB node; deprecated after v0.1.  <br>
 <code>key()</code> is a subclass of <code>node()</code> designed to implement deprecated
 property names for backward compatibility, as follows:</p>

<ul>
    <li><a href="yottadb.html#node:name">name</a> (this node's subscript or variable name)</li>
    <li><code>value</code> (this node's value in the YottaDB database)</li>
    <li><a href="yottadb.html#data">data</a> (see <code>data()</code>)</li>
    <li><a href="yottadb.html#node:has_value">has_value</a> (whether or not this node has a value)</li>
    <li><a href="yottadb.html#node:has_tree">has_tree</a> (whether or not this node has a subtree)</li>
    <li><code>__varname</code> database variable name string -- for compatibility with a previous version</li>
    <li><code>__subsarray</code> table array of database subscript name strings -- for compatibility with a previous version
    and deprecated definitions of <code>key:subscript()</code>, <code>key:subscript_next()</code>, <code>key:subscript_previous()</code> <br></li>
</ul>


    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">varname</span>
         String variable name.
        </li>
        <li><span class="parameter">subsarray</span>
         list of subscripts or table subscripts
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        key object of the specified node with metatable <code>yottadb._key</code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#node">node</a>
    </ul>


</dd>
    <dt>
    <a name = "key:delete_node"></a>
    <strong>key:delete_node ()  [deprecated v1.0]:</strong>
    </dt>
    <dd>
    Deprecated way to delete database node value pointed to by node object.
 Prefer <code>node:set(nil)</code>

    </ul>
    </ul>




    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#kill">kill</a></li>
         <li><a href="yottadb.html#set">set</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscript_next"></a>
    <strong>key:subscript_next ([reset[, reverse]])  [deprecated v1.0]:</strong>
    </dt>
    <dd>

<p>Deprecated way to get next <em>sibling</em> subscript. </p>

<p> <em>Note:</em> this starts from the given location and gives the next <em>sibling</em> subscript in the M collation sequence.
 It operates differently than <code>node:subscripts()</code> which yields all subscripts that are <em>children</em> of the given node.
 Deprecated because:</p>

<ul>
    <li>It keeps dangerous state in the object, causing bugs when stale references attempt to access defunct state.</li>
    <li>It is more Lua-esque to iterate all subscripts in the node (think table) using <code>pairs()</code>.</li>
    <li>If sibling access becomes a common use-case, it should be reimplemented as an iterator.</li>
</ul>


    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reset</span>
         If <code>true</code>, resets to the original subscript before any calls to <code>subscript_next()</code>
         (<em>optional</em>)
        </li>
        <li><span class="parameter">reverse</span>
         If <code>true</code> then get previous instead of next
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#node:__pairs">node:__pairs</a></li>
         <li><a href="yottadb.html#subscript_previous">subscript_previous</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscript_previous"></a>
    <strong>key:subscript_previous ([reset])  [deprecated v1.0]:</strong>
    </dt>
    <dd>
    Deprecated way to get previous <em>sibling</em> subscript.
 See notes for <code>subscript_previous()</code>

    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reset</span>
         If <code>true</code>, resets to the original subscript before any calls to <code>subscript_next()</code>
 or <code>subscript_previous()</code>
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="yottadb.html#node:__pairs">node:__pairs</a></li>
         <li><a href="yottadb.html#subscript_next">subscript_next</a></li>
    </ul>


</dd>
    <dt>
    <a name = "key:subscripts"></a>
    <strong>key:subscripts ([reverse])  [deprecated v1.0]:</strong>
    </dt>
    <dd>

<p>Deprecated way to get same-level subscripts from this node onward.
 Deprecated because:</p>

<ul>
    <li><code>pairs()</code> is more Lua-esque.</li>
    <li>It was non-intuitive that <code>key:subscripts()</code> iterates only subsequent subscripts, not all child subscripts.</li>
</ul>


    </ul>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reverse</span>
         When set to <code>true</code>, iterates in reverse
         (<em>optional</em>)
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="yottadb.html#subscripts">subscripts</a>
    </ul>


</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2024-07-22 17:37:12 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
